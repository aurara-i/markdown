
 Linux 系统的目录结构遵循（Filesystem Hierarchy Standard，文件系统层次结构标准），所有目录都从根目录开始，形成一个树状结构。这种统一的结构让不同 Linux 发行版（如 Ubuntu、CentOS、Debian 等）的目录布局保持一致，方便用户和程序定位文件。
## 核心目录及其功能
### 1. 系统基础与启动相关
- **`/`（根目录）**  
  整个文件系统的起点，所有目录和文件都挂载在根目录下。

- **`/boot`**  
  存放系统启动必需的文件，包括 Linux 内核（`vmlinuz`）、引导加载程序（如 GRUB 的配置文件 `grub.cfg`）、启动镜像等。系统启动时，BIOS/UEFI 会从这里加载内核。

- **`/sbin`**  
  存放**系统管理命令**，仅 root 用户（超级管理员）常用，用于系统维护，如 `reboot`（重启）、`fdisk`（磁盘分区）、`ifconfig`（网络配置，部分发行版已被 `ip` 替代）等。
### 2. 系统配置与核心文件
- **`/etc`**  
  存放**系统和应用程序的配置文件**，是 Linux 中最常用的目录之一。例如：  
  - 网络配置：`/etc/network/interfaces`（网络接口配置）、`/etc/resolv.conf`（DNS 服务器）；  
  - 用户配置：`/etc/passwd`（用户账户信息）、`/etc/group`（用户组信息）；  
  - 服务配置：`/etc/systemd/system`（systemd 服务配置）、`/etc/nginx`（Nginx 服务器配置）。

- **`/lib` 与 `/lib64`**  
  存放系统运行必需的**共享库文件**（类似 Windows 的 DLL 文件）和内核模块（`.ko`）。  
  - `lib` 对应 32 位系统或 64 位系统的兼容库；  
  - `lib64` 仅在 64 位系统中存在，存放 64 位库文件。
### 3. 设备与虚拟文件系统
- **`/dev`**  
  存放**设备文件**（Linux 中“一切皆文件”，硬件设备通过文件抽象）。例如：  
  - 硬盘：`/dev/sda`（第一块 SATA 硬盘）、`/dev/nvme0n1`（第一块 NVMe 硬盘）；  
  - 终端：`/dev/tty1`（第一个虚拟终端）；  
  - 光驱：`/dev/cdrom`。

- **`/proc`**  
  虚拟文件系统（不占用磁盘空间，数据存于内存），反映**系统实时状态**。例如：  
  - 进程信息：`/proc/1234`（PID 为 1234 的进程详情）；  
  - 系统资源：`/proc/meminfo`（内存使用情况）、`/proc/cpuinfo`（CPU 信息）。

- **`/sys`**  
  虚拟文件系统，主要用于**硬件设备的配置与状态查询**，比 `/proc` 更侧重硬件细节。例如：`/sys/class/net`（网络接口信息）、`/sys/devices`（设备树）。


### 4. 用户与应用相关
- **`/home`**  
  普通用户的**家目录**，每个用户在这里有独立的子目录（如 `/home/zhang`、`/home/lisi`），用于存放用户的个人文件（文档、下载、配置等）。
- **`/root`**  
  超级管理员（root 用户）的家目录，与普通用户的 `/home` 分开，权限更高。
- **`/bin`**  
  存放**基础用户命令**，所有用户均可访问，且系统启动时就需要这些命令（如 `ls` 列表、`cp` 复制、`mkdir` 创建目录等）。
- **`/usr`**  
  存放“用户可共享的程序和数据”，是系统中最大的目录之一，内部结构类似根目录：  
  - `usr/bin`：非启动必需的用户命令（如 `gcc` 编译器、`python` 解释器）；  
  - `usr/sbin`：非启动必需的系统命令（如 `apache2` 服务器启动命令）；  
  - `usr/lib`：应用程序的库文件；  
  - `usr/share`：共享数据（如文档、图标、字体等）；  
  - `usr/local`：用户手动安装的软件（如源码编译的程序，避免与系统自带软件冲突）。
- **`/opt`**  
  存放**第三方可选应用**（通常是大型软件），如 Oracle 数据库、Matlab 等，方便集中管理和卸载。

### 5. 临时与可变数据
- **`/tmp`**  
  临时文件目录，所有用户可读写，系统会定期自动清理（或重启后清空），适合存放临时缓存、日志等。

- **`/var`**  
  存放**“可变数据”**（内容随系统运行动态变化）：  
  - `var/log`：系统和应用程序的日志文件（如 `syslog` 系统日志、`auth.log` 登录日志）；  
  - `var/cache`：应用程序的缓存（如浏览器缓存、软件包缓存）；  
  - `var/mail`：用户邮件；  
  - `var/spool`：队列数据（如打印任务、定时任务）。


### 6. 外部存储挂载
- **`/mnt`**  
  手动挂载外部存储设备（如 U 盘、移动硬盘、网络共享目录）的临时挂载点，例如 `mount /dev/sdb1 /mnt/usb` 可将 U 盘挂载到 `/mnt/usb`。

 - **`/media`**  
  自动挂载外部设备的目录（现代 Linux 发行版常用），插入 U 盘或光盘时，系统会自动在 `/media/用户名/设备名` 下创建挂载点。


## 总结
Linux 目录结构的设计遵循“功能分离”原则：系统文件与用户文件分离、静态文件（如程序）与动态文件（如日志）分离、必需文件与可选文件分离。理解这些目录的作用，能帮助你快速定位文件、排查问题（如日志在 `/var/log`，配置在 `/etc`），是使用 Linux 的基础。
## linux中ubuntu安装软件操作
### 通过APT安装包安装
- sudo apt update
- sudo apt install firefox
- sudo apt remove firefox
- sudo apt upgrade  # 升级所有可更新的软件
- sudo apt upgrade firefox  # 仅升级指定软件
- apt search [关键词]  # 例如查找 "编辑器" 相关软件：apt search editor
### 源码编译安装
安装编译工具（首次编译需执行）：
- bash
- sudo apt install build-essential  # 包含 gcc、make 等基础编译工具
下载并解压源码包：
例如下载 example-1.0.tar.gz 后，在终端解压：
- bash
- tar -zxvf example-1.0.tar.gz  # 解压 gz 格式
- cd example-1.0  # 进入解压后的目录
配置编译参数：
大多数源码包会提供 configure 脚本，用于检查依赖并生成 Makefile：
- bash
./configure  # 可添加参数，如指定安装路径：./configure --prefix=/usr/local
编译源码：
- bash
- make  # 编译过程可能耗时，取决于软件复杂度
安装编译好的软件：
- bash
- sudo make install
卸载源码安装的软件（需在源码目录执行）：
- bash
- sudo make uninstall


# 视觉SLAM 
## 定位和建图
### 传感器
- 机器人：轮式编码器、相机、激光、imu
- 环境：导轨、二维码标志
### 相机
 拍摄的图像需要恢复三维结构，恢复相机的运动和远近大小。
 单目相机通过视差可以定量的判断远近，但是存在尺度不确定性。
 双目相机可以获得尺度信息，但是计算量大。深度相机适合室内。
### SLAM框架
![](https://github.com/aurara-i/markdown/blob/main/picture/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-04%20185108.png)
- 前端视觉里程计：估算相邻图像之间相机运动。每次估计会存在偏差，因此会存在累积飘移，因此需要进行后端优化和回环检测。（计算机领域）
- 后端优化：接受相机位姿和回环检测进行优化。主要就是处理噪声问题。（滤波与非线性优化）
- 回环检测：判断机器人是否到达过先前的位置，如果检测到回环提供给后端。解决为位置随时间飘移问题。
### 数学表达
- 运动：轨迹由离散的时间k和离散时间的位置xk构成。用运动方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/3.png)
  u为观测量，w为噪声。
- 观测：观测在k时刻处于xk位置观测到地图上路标yk。用观测方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/4.png)  
  v为噪声。
上述通过两个方程，通过运动观测u和传感器读数Z解决定位问题（x）和建图(y)问题。 建模为状态估计问题：线性/非线性，高斯/非高斯。
其中线性高斯系统的无偏最优估计可以由卡尔曼滤波获得。（预测与更新）我觉得上面的运动就是状态矩阵，观测就是更新矩阵。
而目前主要使用图优化进行状态估计。
### Kalman Filter（https://blog.csdn.net/qq_37214693/article/details/130927283?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&utm_relevant_index=2）
  - 卡尔曼滤波的原理是赋予权重，判断哪个信息的可信度高，可信度高的就赋予更高的权重，可信度低的赋予权重低，由此获得最优估计。
  - 基于状态信息的运动方程获得先验状态矩阵，传感器量测到的状态值获得状态观测矩阵。两者结合处理后获得后验状态矩阵。最优估计为其中心。
- 1、状态方程 xₖ = Fₖxₖ₋₁ + Bₖuₖ + wₖ
  - xₖ	时刻 k 的 “状态向量”	，Fₖxₖ₋₁	前一时刻状态对当前的影响	，Bₖuₖ	输入信号对当前状态的影响	，wₖ	过程噪声（随机变量）	，cov{wₖ}=Qₖ	噪声的协方差矩阵
- 2、观测方程 zₖ = Hₖxₖ + vₖ
  -zₖ	时刻 k 的 “观测向量”	，Hₖxₖ	状态对观测的 “理想映射”	，vₖ	观测噪声（随机变量），cov{vₖ}=Rₖ	观测噪声的协方差矩阵	
#### 是先通过状态方程 “预测” 当前状态，再用观测方程的实际测量结果 “校正” 这个预测值，最终得到更接近真实状态的估计值。如果发现预测的状态偏了就进行修正。若观测噪声 vₖ小（GPS 精度高，Rₖ小），就 “多信观测”，让修正后的状态更靠近 zₖ；若过程噪声 wₖ小（状态预测准，Qₖ小），就 “多信预测”，少修正一点。
![](https://github.com/aurara-i/markdown/blob/main/picture/5.png)
- 3、状态估计误差 \(\tilde{x}_{k|k - 1} = x_k - \hat{x}_{k|k - 1}\) 
  - x_k：k 时刻系统的真实状态。这是客观存在的物理量，但无法直接获取（只能通过估计逼近）。
  - k-1 时刻对 k 时刻状态的预测估计值
  -k 时刻的预测误差（也称 “先验误差”），即 “真实状态与预测估计值的偏差”。
- 4、状态估计方程 
  - 利用 k-1 时刻的最优状态估计和 k 时刻的控制输入，预测 k 时刻的状态
- 5、观测估计误差 
- 6、观测估计方程
####  这里的估计，不包含随机且不确定的误差。卡尔曼滤波通过 “先做无噪声的理想预测，后续再用噪声的统计特性（协方差）修正” 的两步法，间接处理了噪声的影响，既保证了估计的 “基础逻辑简洁性”，又能通过统计方法实现 “最优修正”。
- 7、状态误差协方差矩阵 
- ![](https://github.com/aurara-i/markdown/blob/main/picture/6.png)
- 8、观测误差协方差矩阵
- 9、 迭代估计表达式  \(\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k \tilde{e}_k\) 
 #### 这里的K就是卡尔曼增益。因此，我们需要推导出所用变量的迭代式，并求得卡尔曼增益。这是核心权重。如果 “猜测的观测” 很不准，或 “观测噪声” 很准，增益  就大（更信观测）；反之则小（更信猜测）。
-后验估计
-  ![](https://github.com/aurara-i/markdown/blob/main/picture/7.png)
 ####  状态估计误差：下标 (k|k-1) 的含义是k 时刻的状态，基于k-1 时刻的信息进行估计”。因为 k-1 时刻时，k 时刻还未到来，只能预测未来（用过去的信息猜未来的状态），所以用 “(k|k-1)” 明确 “估计的时间逻辑”——“基于过去，估计未来”。而观测估计误差下标 k 的含义是 “k 时刻的观测”。因为观测 (z_k) 是k 时刻实时获取的测量值（比如 GPS 在 k 时刻的读数），误差直接对应 “当前时刻（k）的观测”，所以用简洁的 k 表示 “这是 k 时刻的观测相关误差”。
![](https://github.com/aurara-i/markdown/blob/main/picture/8.png)
## G++编译器
- `g++ helloslam.cpp`生成./a.out的可执行文件，在终端中输入这个可执行文件就可以成功运行。
## CMAKE基础
 - 这确实是我第一次真正生成Cmake。值的记录！！
  - 新建并在CMakeLists.txt中写
  - **` cmake_minimum_required(VERSION 3.10)#声明的要求最低版本CMake `**
  - **` project(Untitled-1)#声明工程 `**
  - **` add_executable(Untitled-1 Untitled-1.cpp)#添加可执行程序（程序名 源代码文件）`**
   - 然后在终端输入cmake . 就会生成一些中间文件。
   - 再输入make进行编译
 - 编译成功后输入：./Untitled-1 可执行程序就能够执行了,输出helllo slam!
 - 所以如果想要新增一个可执行文件，只需要再添加一行就行。
 - 我们希望生成的中间文件不要放在代码目录中，新建一个build目录然后进行Cmake和make
 -  **如何生成库**
 - 我们自己生成库，在cmakelist.txt中增加：add_library( .cpp),然后和上面一样cmake编译就行。生成的.a文件就是想要的库。
 - 还需要一个头文件才能够调用库。头文件包括宏定义和函数名
 - 然后在cmakelist中增加可执行程序的生成命令连接到库上，target_link_libraries()
## 三维刚体运动 
 - **内积**  内积是描述向量之间的投影关系。
 - **外积**  外积的结果是一个向量，方向垂直于这两个向量，是两个向量张成的四边形的有向面积。向量叉乘 a×b 的结果可以通过将向量 a 转化为反对称矩阵 a∧ 后与向量 b 做矩阵乘法。

 - 如图，把外积写成了矩阵与向量的乘法，变成了线性运算。任意向量都唯一对应一个反对称矩阵。
- **刚体运动** 运动过程中向量大小不会发生变化。
- **欧式变换** 导航坐标系和世界坐标系之间差了一个欧式变换，欧式变换由旋转和平移构成。
- **旋转矩阵（方向余弦矩阵）** R12 表示把坐标系2的向量变换到1中。求逆表示反向的旋转。

- 如图，旋转矩阵来源。
- 对于**旋转矩阵的实践**，我们主要使用EIGEIN库进行矩阵的计算。这个库是由纯头文件构成，无需连接库文件，只需引入头文件即可。
- **Eigien库矩阵的使用**
- 所以在CMakeLists.txt中 include_directories( "/usr/include/eigen3" )
    -- **可以省略的情况：**
    Eigen 是纯头文件库，若其安装路径在系统默认的头文件搜索路径中（如 Linux 的/usr/include、/usr/local/include，或通过包管理器安装时自动配置的路径），CMake 会自动找到它，无需手动指定。
    -- **必须保留的情况：**
    若 Eigen 安装在非默认路径（如自定义目录、Windows 系统中手动解压的路径），则必须通过这行指定头文件位置，否则编译时会提示 “找不到 Eigen 头文件”。
- `Eigein::Matrix<double ,3 ,3> Matrix3d;`//三维矩阵原始定义
- `Eigein::Matrix3d matrix3d=Eigein::Matrix3d::Zero()`//内置的三维矩阵直接调用，可初始化为0
- `Eigein::Matrix<double,Eigein::Dynamic,Eigein::Dynamic> Matrixnd`//矩阵大小动态设置
- `matrix3d=1,2,3,4,5,6,7,8,9;`//三维矩阵初始化
- `cout<<matrix3d;`//进行输出
- `for（int i=0；i<3;i++） for(int j=0;j<3;j++) cout<<matrix3d(i,j)`//访问特定元素
- `.transpose 转置 .trace 迹 .inverse 逆 .determinant行列式`
- `Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> eigen_solver ( matrix_33.transpose()*matrix_33 );`//使用 Eigen 库中的SelfAdjointEigenSolver类来求解一个 3x3 矩阵的特征值和特征向量
    - matrix_33.transpose() * matrix_33
    对原始矩阵matrix_33做转置（.transpose()）后，再与自身相乘。
    数学意义：这样得到的新矩阵一定是对称矩阵（满足A^T = A），且是半正定的（特征值非负）。
    - Eigen::SelfAdjointEigenSolver<...>
    这是 Eigen 中专门用于求解对称矩阵特征值和特征向量的工具类（SelfAdjoint表示 “自伴随”，即对称矩阵）。
    - `eigen_solver`
    是实例化的求解器对象，通过它可以获取计算出的特征值和特征向量。
 - 解方程
    - 直接求逆
    - 史密特正交化`x = matrix_NN.colPivHouseholderQr().solve(v_Nd);`
 -**旋转向量与欧拉角**
 - 旋转向量：任何旋转都可以由一个旋转轴和旋转角刻画，我们用一个向量方向和旋转轴一致，长度等于旋转角对旋转刻画。
 - 三维空间中的刚体运动共有六个自由度：三个旋转自由度 + 三个平移自由度；旋转向量可把旋转压缩为三维，平移向量本身是三维，两者拼起来正好六维，能无冗余且完备地描述刚体变换。而上面的旋转矩阵用十六个量表示了六个自由度的变换。 从旋转向量到旋转矩阵的转换过程为**罗德里格斯公式**。
 - 旋转矩阵R是 3×3 矩阵（9 个元素），但它必须满足 **“正交性” 和 “右手坐标系”** 两个核心约束，这会消除 6 个自由度，最终只剩 3 个独立参数。
 - 对于 3×3 矩阵，RTR=I意味着：
    - 每行（或列）都是单位向量（3 个方程）：比如第一行满足r112​+r122​+r132​=1；
    - 不同行（或列）互相垂直（3 个方程）：比如第一行和第二行满足r11​r21​+r12​r22​+r13​r23​=0。
    - 共 6 个方程，每个方程都会减少一个自由度，因此 9 - 6 = 3。
 - 旋转轴是三维空间中的一个单位向量n=(nx​,ny​,nz​)，但 “单位向量” 的约束会减少一个自由度，因此从 3 个参数变成 2 个独立参数。旋转角为一个自由度。
 - **欧拉角**
 - 把旋转等价于三个分离的转角，三次绕不同轴的转动。俯仰、横滚、偏航。存在万向锁的问题，奇异性。同理，上面的旋转向量在180度的时候也会存在奇异性。
 - **四元数**
 - 没有奇异性。q=q0+q1i+q2j+q3k
    -q0​ 是实部，q1​,q2​,q3​ 是虚部（对应三维空间的 3 个维度）；i,j,k 是四元数的虚数单位，满足特殊的乘法规则：i2=j2=k2=−1，ij=k,jk=i,ki=j（右手定则），且乘法不满足交换律（如 ji=−k）。
 - 表示旋转：
   - 旋转四元数的关键约束：**单位四元数**。并非所有四元数都能表示旋转 ——只有 “单位四元数”（模长为 1 的四元数）才能描述旋转。这一约束的本质是：旋转不改变向量的长度，单位四元数的乘法能保证 “长度不变性”（类似旋转矩阵的正交性）。
   - 三维空间的任意旋转，都可唯一分解为 “绕某一固定轴旋转特定角度”（欧拉旋转定理）。四元数正是直接对应这一分解：
   - 若旋转的单位轴向量为 u=[ux​,uy​,uz​]T（∥u∥=1），旋转角为 θ（右手定则：拇指沿 u 正向，四指弯曲方向为旋转方向），则对应的单位四元数为：
   - q=cos(2|θ​)+ux​sin(2|θ​)i+uy​sin(2|θ​)j+uz​sin(2θ​)k
   - 可简化为 “实部 + 虚部向量” 的形式：
   - q=[cos(2θ​),ux​sin(2θ​),uy​sin(2θ​),uz​sin(2θ​)]T
实部表示旋转角度，虚部表示旋转方向。
 -  θ/2 编码能完美匹配现实中的旋转效果 —— 这是因为 θ/2 编码恰好抵消了 “四元数乘法的双线性特性”（数学上，四元数旋转对应 “SU (2) 群”，而 3D 旋转对应 “SO (3) 群”，θ/2 是这两个群同态映射的关键）。
 - **几种旋转之间转换**
 - **旋转变化明天再看把，困死了**
 - 相似变换：旋转、平移、缩放
 - 仿射变换：旋转矩阵不要求正交
 - **Eigein库中旋转的使用**
   - 在 Eigen 中，**AngleAngleAxis** 是一种专门用于表示旋转向量的类，它的底层实现不是矩阵，而是直接存储了 “旋转角度” 和 “旋转轴方向” 这两个核心信息。
   - ` Eigen::AngleAxisd rotation_vector ( M_PI/4, Eigen::Vector3d ( 0,0,1 ) );`
   -  **旋转向量 转 旋转矩阵**
   - `cout<<"rotation matrix =\n"<<rotation_vector.matrix() <<endl;` //直接转为矩阵
   - 也可以`rotation_matrix = rotation_vector.toRotationMatrix();`//或者用这个函数
   - **旋转矩阵 转 欧拉角**
   - `Eigen::Vector3d euler_angles = rotation_matrix.eulerAngles ( 2,1,0 ); // ZYX顺序，即roll pitch yaw顺序`
   - **用旋转向量和旋转矩阵进行坐标变换**
   -  `::Vector3d v ( 1,0,0 );`
   -  `Eigen::Vector3d v_rotated = rotation_vector * v;`
   -  `v_rotated = rotation_matrix * v;`
   -  **欧式变换矩阵**
   -  `Eigen::Isometry3d T = Eigen::Isometry3d::Identity();`
   -  `Isometry3d 是 Eigen 中专门用于表示三维欧氏变换的类（“Isometry” 意为 “等距变换”，即保距变换）。虽然名字带 “3d”，但内部存储的是 4×4 矩阵（因为需要包含平移部分）。`
   -  `T.rotate(rotation_vector);  // 应用之前定义的旋转向量，当然，这里换成其他旋转的表达也是ok的`
   -  `T.pretranslate(Eigen::Vector3d(1,3,4));  // 平移向量 t = (1,3,4)`
   -  也可以直接`Eigen::Vector3d v_transformed = T * v;  // v 是初始向量 (1,0,0)`
   -  这里的 * 运算符是 Eigen 重载的欧氏变换操作，等价于数学上的：vtransformed​=R⋅v+t
即 “先对向量 v 应用旋转 R，再加上平移 t”。
   -  **四元数**
   - `Eigen::Quaterniond q = Eigen::Quaterniond(rotation_vector);`
   - `q = Eigen::Quaterniond(rotation_matrix);`
   - `v_rotated = q * v;  // 数学上等价于 q·v·q⁻¹`//用四元数旋转一个矩阵
  - **可视化演示**
  - **小萝卜的例子**
  - 1、四元数先转的在右侧，我给忘记了。
  - 2、四元数一定要定义完成后归一化。
  - 3、**这里的位姿原来指的是再载体坐标系下的，所以对于旋转向量直接q1q2之间求就可以了。对于位置平移向量，要先把t1转回世界坐标系再转到2。**
<br>**李群李代数 抽象的一**<br>  （讲的很好：https://juejin.cn/post/7499014256548200474   https://juejin.cn/post/7502610991740026906）
<br>群：一种集合加一种运算。具有封闭性、结合律、幺元、逆的性质。<br>
<br> 李群：具有连续性质的群。对乘法是封闭的但是对加法不是封闭的。李群是具有光滑性质的群，它意味着这个函数的每个点都可以用切线方程来近似，从而使得复杂的问题可以通过简单的线性问题来解决，极大地简化了计算。两个重要的李群是特殊正交群SO(n)SO(n) 和 特殊欧式群SE(n)SE(n)，特殊正交群是旋转变换的集合和运算，特殊欧式群是欧式变换/刚性变换的集合和运算。<br>
<br>旋转群 SO (3)：三维空间中绕任意轴的旋转（比如地球自转、方向盘转动）。这些旋转操作满足 “群的 4 条规则”（封闭性：两个旋转叠加还是旋转；结合律：旋转顺序不影响最终结果；单位元：不旋转的 “零操作”；逆元：转 30° 再转 - 30° 回到原位），且旋转角度可以连续从 0° 变到 360°，是典型的李群。<br>
<br>平移群：在平面上把一个点从 (0,0) 连续移到 (1,1)，所有平移操作也构成李群。<br>
<br>定义：SO (3) 是所有 3×3 实正交矩阵且行列式为 1 的集合，即
SO(3)={R∈R3×3∣RTR=I,det(R)=1}
其中 RT 是矩阵 R 的转置，I 是 3 阶单位矩阵，det(R)=1 确保旋转无反射。<br>几何意义：SO (3) 中的每个元素 R 唯一对应三维欧氏空间 E3 中绕某条过原点的轴的旋转操作，即 “三维旋转的全体集合”。<br>
<br>李代数的引入，对旋转矩阵求☯，等于一个反对称矩阵乘以这个旋转矩阵 ，也就是说每对旋转矩阵求一次☯就左乘一个反对称矩阵。这样构成了一个一阶微分方程，求出的结果就是旋转矩阵和反对称矩阵之间的指数关系。这个反对称矩阵就是旋转矩阵对应的李代数。 <br>
<br>李代数定义：李代数是由两部分组成的 “数学对象”，记为 (g,[⋅,⋅])，其中：
    <br>g（读作 “g frak”）：一个线性空间（可以简单理解为 “一堆能做‘加法’和‘数乘’的元素”，比如三维空间里的向量、矩阵集合等）；
    <br>[⋅,⋅]（读作 “李括号”）：定义在 g 上的二元运算（即 “拿两个元素，通过这个运算得到第三个元素，且结果仍在 g 里”）。李代数的所有性质，都是对这个 “李括号” 的规则约束。
    <br>性质 1：双线性（Bilinearity）—— 运算对 “加法” 和 “数乘” 友好.保证李代数能和 “线性空间” 的结构结合 —— 线性空间本身有加法和数乘，李括号的双线性让这两种结构不冲突，不会出现 “算完李括号就超出线性空间” 的情况。[ax+by,z]=a[x,z]+b[y,z]
   <br>性质 2：反交换性（Anticommutativity）—— 交换输入，结果变号。把李括号的两个输入 “换位置”，得到的结果是原来的 “相反数”： 这是李代数区别于普通 “代数” 的关键之一。普通乘法（比如数的乘法、矩阵乘法）是 “交换的”（xy=yx），但李括号是 “反交换的”—— 它描述的往往是 “非交换的相互作用”
<br>性质 3：雅可比恒等式（Jacobi Identity）—— 三个元素的 “循环作用” 平衡
对任意三个元素 x,y,z，满足：[x,[y,z]]+[y,[z,x]]+[z,[x,y]]=0<br>
<br> ϕ​1​,ϕ​2​：是 李代数 so(3) 中两个元素,.Φ​1​=ϕ​1∧​,Φ​2​=ϕ​2∧​：是将三维向量转化为反对称矩阵的结果
<br> [ϕ​1​,ϕ​2​]=(Φ​1​Φ​2​−Φ​2​Φ​1​)∧ //我们可以把 ϕ​ 想象成 “想让物体往某个方向转的念头”，李括号 [ϕ​1​,ϕ​2​] 就是 **“两个旋转念头相互作用后，产生的新念头”**。
    矩阵乘法的非交换性（Φ​1​Φ​2​=Φ​2​Φ​1​ 一般成立），使得交换子能刻画 “先按 Φ​1​ 作用再按 Φ​2​ 作用” 与 “先按 Φ​2​ 作用再按 Φ​1​ 作用” 的差异。再通过反对称化的逆映射 ∧−1（即式中的 (⋅)∧ 在此处为逆操作，将反对称矩阵映射回三维向量），将交换子的结果投影回 R3，得到李括号 [ϕ​1​,ϕ​2​]。<br>
<br>李代数 so (3) 并非孤立存在，而是通过指数映射（Exponential Map） 与李群 SO (3) 建立 “局部一一对应”，通过对数映射（Logarithmic Map） 实现反向映射，这是李代数 “生成” 李群的关键机制。<br>
<br>反对称矩阵的指数可以进行泰勒展开，任意的一个反对称矩阵都对应着一个三维向量，可以定义这个向量的模长和单位方向向量a。由这个方向向量的性质，可以将泰勒展开的高阶项进行计算，将李代数转化为李群。最后也会获得罗德里哥斯公式，。<br>
<br>经过这个推导，我们可以知道李代数空间就是由旋转向量组成的空间。而由李代数到李群就可以利用旋转向量到旋转矩阵之间的关系获得。<br>
<br>当对一个旋转矩阵R2R_{2}R2​(李代数为ϕ2\phi_{2}ϕ2​)左乘一个微小旋转矩阵R1R_{1}R1​(李代数为ϕ1\phi_{1}ϕ1​)时，可以近似的看作，在原有李代数ϕ2\phi_{2}ϕ2​上加上一项Jl(ϕ2)−1ϕ1J_{l}(\phi_{2})^{-1}\phi_{1}Jl​(ϕ2​)−1ϕ1​。<br>
<br>**相机与图像**<br>
<br>**针孔模型** 这个比较简单，就是利用小孔成像和相似三角形原理。**像素坐标系**原点位于左上角，向右为u轴，向左为v轴，像素坐标系和成像平面之间差了一个缩放和原点平移。**相机内参** xy原点，fx fy焦距，出场后是固定的。确定内参的过程叫做标定。**相机外参**P点的相机坐标，是它的世界坐标系根据位姿转换到相机坐标系下。外参就是旋转矩阵和平移向量。世界坐标系通过旋转矩阵和平移向量转到相机坐标系下，然后通过内参，把相机坐标系下的坐标转为像素坐标系下。
  <img width="107" height="240" alt="图片" src="https://github.com/user-attachments/assets/dd74678c-da85-46e0-8c3b-0f152cf4bb83" />
<img width="172" height="51" alt="图片" src="https://github.com/user-attachments/assets/0c7c52e2-6c2d-41ac-965e-5d7aeb9671c2" />
<img width="377" height="279" alt="图片" src="https://github.com/user-attachments/assets/db8d7518-221e-41e0-8fbe-49ffa11e49be" />

<br>**畸变模型** 我们在相机前面加了透镜，透镜形状引起的畸变称为径向畸变。分为：桶形和枕形畸变。由于相机组装中，透镜和成像平面不平行，会引起切向畸变。径向畸变系数k1 k2  k3  ,切向：p1  p2 。通过这五个畸变系数去计算发生畸变后的坐标。我们就可以获得点在像素平面上的正确位置了。**畸变公式如下图**<br>
<br>**双目相机模型** 单目相机无法获得深度信息，没有办法获得空间点的具体位置。双目相机通过同步采集左右相机的图像，计算图像之间的视差，便于估计像素的深度。原理依旧是利用相似三角形。<br>
<br>**RGB-D相机模型**主要原理：1、红外结构光：根据返回的结构光图案，计算距离。2、飞行时间原理：发送返回光束飞行时间。<br>
<br>**图像**在灰度图中每个像素位置对应着一个灰度值，一般来说图像是以二维数组的形式存储。第一个表示行，对应图像的高度，对应着Y轴，第二个表示列，对应图像宽度，对应着X轴。这里方向不要弄混。<br>
<br>**OPENCV实践**<br>
  - Opencv库的安装，在https://opencv.org/releases/网址中下载需要的版本即可，依旧利用上述cmake编译的过程进行编译即可，需要注意的是提前安装好Opencv的依赖项。还要利用sudo make install进行安装到机器上。
  - **利用opencv对图像进行处理(基础操作)**
    - #include <chrono> C++ 标准时间库（chrono），用于精确计算代码执行时间（比如后续遍历图像的耗时统计）。
    - cv::Mat image;OpenCV 中存储图像的数据结构（类似 “图像矩阵”），可理解为 “容器”，用来存放像素数据、图像尺寸、通道数等信息；image是变量名，此时还未赋值
    - image = cv::imread ( argv[1] ); //cv::imread函数读取指定路径下的图像。<br>cv::Mat imread(const String& filename, int flags = IMREAD_COLOR);

第二个参数 flags 决定如何读图：

    IMREAD_COLOR（默认，值=1）：读成三通道 BGR 8 位。

    IMREAD_GRAYSCALE（值=0）：读成单通道灰度 8 位。

    IMREAD_UNCHANGED（值=-1）：保持原始数据格式（不做任何转换）。

为什么深度图要用 -1？

    深度图一般是 16 位无符号整数（unsigned short），单位是毫米。

    如果用默认 1 或 0，OpenCV 会自动把它转成 8 位（0~255），深度信息就丢失了。
    - // 文件顺利读取, 首先输出一些基本信息:cout<<"图像宽为"<<image.cols<<",高为"<<image.rows<<",通道数为"<<image.channels()<<endl;
    - cv::imshow ( "image", image );      // 用cv::imshow显示图像
    - cv::waitKey ( 0 );                  // 暂停程序,等待一个按键输入
    - **cv拷贝机制**
    - cv::Mat的浅拷贝（重点特性）：
    <br>直接用=赋值时，image_another并不会复制image的像素数据，而是和image共享同一块内存（相当于 “起别名”）。
    此时修改image_another的像素，image的像素也会跟着变（因为内存是共享的）。<br>// 修改 image_another 会导致 image 发生变化image_another ( cv::Rect ( 0,0,100,100 ) ).setTo ( 0 ); <br>// 将左上角100*100的块置零<br>cv::Rect(x, y, width, height).setto(0)：创建一个矩形区域，参数分别是 “左上角 x 坐标、左上角 y 坐标、宽度、高度”，image_another(Rect(...))：获取image_another中矩形区域的子图像（依然是浅拷贝，共享内存）
    - cv::Mat::clone()：深拷贝函数
    <br>// 使用clone函数来拷贝数据
    <br>cv::Mat image_clone = image.clone();
    <br>深拷贝函数，会创建一个新的cv::Mat对象，并复制image的所有像素数据（内存不共享，是完全独立的副本）。
此时修改image_clone，image不会受到任何影响。
    - 遍历所有元素
      <br>循环的核心是 “逐行、逐列、逐通道” 遍历图像的所有像素，本质是通过 “指针操作” 高效访问图像在内存中的原始数据。
  - **图像转点云**
   - **读取数据**
    循环读取 5 组数据：
        用格式化路径（如./color/1.png）读取彩色图和深度图，存入容器；
        从pose.txt读取每张图对应的相机位姿（平移 + 旋转），用 Eigen 库转换为位姿变换矩阵（包含旋转和平移），存入容器。
    - **设置参数与初始化**
    配置相机内参（焦距、图像中心、深度缩放因子），用于像素坐标转 3D 坐标；
    定义带颜色的点云格式（XYZRGB），初始化点云对象。
    - **像素→点云转换（核心）**
    遍历每张图像的每个像素：
        读取深度值，跳过无效值（深度为 0）；
        用相机内参将 “像素坐标 + 深度” 转换为相机坐标系下的 3D 点；
        用相机位姿将 3D 点从相机坐标系转换到世界坐标系；
        读取彩色图对应像素的颜色（BGR），存入点云的颜色字段，再将点添加到点云。
    - **保存点云**
    标记点云属性（非稠密），输出点的总数，最后将点云保存为map.pcd文件。
   - **非线性优化**
     - **状态估计问题**
     - 所以我们第二章说的SLAM模型包括一个运动方程和一个观测方程，运动方程就是运动位姿SE，观测方程就是相机针孔模型。
     - 滤波器：在机器人运动过程中，融合 “机器人的运动信息”（如里程计、IMU 数据）和 “环境的观测信息”（如激光、视觉数据），处理传感器噪声和模型误差，实时估计出机器人的当前位姿（定位）和环境的地图（建图）。只关心当前时刻的状态估计，如：卡尔曼滤波器
     - 批量：而 “批量处理” 的核心就是把 “所有相关观测的误差” 加起来，找一个能让总误差最小的位姿和地图。可以在更大的范围内实现优化，如：BA优化算法。
     - 例子：比如第 3 帧的位姿因为 IMU 漂移有小误差，导致第 3 帧观测的路标点坐标也偏了；
    <br>递归处理（如 EKF）：第 4 帧只会基于第 3 帧的错误位姿继续更新，误差会越积越大；
    <br>批量处理（BA）：优化时会发现 “第 3 帧的位姿偏差导致后续多帧的误差都变大”，于是会回溯修正第 3 帧的位姿，同时调整所有相关路标点的坐标，让整体误差最小。
    - P(x,y∣z,u)=P(z,u)P(z,u∣x,y)⋅P(x,y)​∝P(z,u∣x,y)⋅P(x,y)
<br>x,y	状态：x 是机器人的位姿序列，y 是路标点坐标	
<br>z,u	数据：z 是观测（如图像），u 是输入（如 IMU）	
<br>P(x,y∣z,u)	后验概率：已知观测 z 和输入 u 时，状态 x,y 的概率	
<br>P(z,u∣x,y)	似然（Likelihood）：已知状态 x,y 时，观测 z 和输入 u
<br>P(x,y)	先验概率（Prior）：没有观测和输入时，状态 x,y 的概率	
<br>P(z,u)	证据（Evidence）：观测 z 和输入 u 本身出现的概率
<br>当我们未知先验就可以求解最大似然估计，在什么样的状态下，最可能观测到数据因为直接获得后验分布很困难，所以我们求得状态最优估计，使得在该状态下后验概率最大。
    - **当观测噪声是高斯分布时，“找最可信的位姿和地图”（最大似然）可以转化为 “最小化观测误差的加权平方和”（最小二乘）**
    <br>(xk​,yj​)∗=argmin(zk,j​−h(xk​,yj​))⊤Qk,j−1​(zk,j​−h(xk​,yj​))Qk,j​ 是 “观测噪声的协方差矩阵”，描述了观测误差的统计特性
   - **非线性最小二乘**
 <br>对于无法得知全局性质的目标函数，我们没办法求导获得极值，因此需要利用迭代的方式，不断更新当前的优化变量，通过不断增加x，找到最小的函数值。
   - **一阶、二阶梯度法**
<br>将目标函数在目标点附近展开，一阶前面的系数成为雅可比矩阵，二阶前面的系数成为海塞矩阵。对应的求解方法成为一阶梯度或者二阶梯度法。
<img width="634" height="116" alt="图片" src="https://github.com/user-attachments/assets/6a8552be-b063-46b6-ad38-cf6bd87e253c" />
如果只保留一阶，然后对右边的式子对Δx求导得导数等于J(x)，这意味着当Δx = J(x)的时候，这个函数最大。那么如果我们想要这个函数最小的时候，取Δx = -J(x)。如果保留二阶，HΔx = -J 。

<br>最速下降法：一阶的时候取增量为反向梯度，X=-J，目标函数一定会下降。**注意这里的X=-J只是一个方向，需要通过乘以步长获得最优结果**优点:最速下降求解简单,只需求解一阶导数
缺点: 但是梯度方向一开始并不一定指向全局最小值,如图所示.因此在实际中,最速下降法很可能走出一条及其曲折的路线,导致其收敛速度很慢,不实用。
<br>牛顿法：HX=-J。牛顿法迭代次数少,但需要计算复杂的H矩阵.并且H不一定是正定矩阵。
<br><img width="2135" height="449" alt="图片" src="https://github.com/user-attachments/assets/e588e12e-4480-4775-852c-72b0cf9da9b3" />
<img width="582" height="539" alt="图片" src="https://github.com/user-attachments/assets/094a911d-8055-412a-8d4e-032175510732" />
<img width="1" height="1" alt="图片" src="https://github.com/user-attachments/assets/f347d3fc-7f93-4a7b-839a-3c1518231919" />

   - **高斯牛顿法**（专门用于解决非线性最小二乘问题）先线性化残差，再对线性化后的残差平方求导
   - https://i-blog.csdnimg.cn/direct/61adda3ac98d40b4a0c1ec73bab704ee.png
   - 避免了牛顿法中H阵的大量计算，但是增量过大时容易不收敛。
   - **列文伯格-马夸尔特方法（LM算法）**(当相信局部二次近似是准确的时，就更像高斯-牛顿法（追求速度）；当不相信时，就退化成更稳健的梯度下降法（保证收敛）。)
   - <img width="483" height="195" alt="图片" src="https://github.com/user-attachments/assets/28fc7082-d8f6-4546-b52b-b331f1b584a0" />

   - 高斯牛顿法中采用的近似二阶泰勒展开只能在展开点附近有较好的近似效果，所以很自然地想到给 ∆x 添加一个范围，称为信赖区域(Trust Region)。这个范围定义了在什么情况下二阶近似是有效的，这类方法也称为信赖区域方法(Trust Region Method)。在信赖区域里边，我们认为近似是有效的；出了这个区域，近似可能会出问题。（同理：牛顿法通过求解 “展开式的极小点” 得到步长 Δx=−H(x)−1∇F(x)。但这一近似仅在 Δx很小时成立 —— 如果步长过大，二阶展开式会偏离原函数，导致 “近似的极小点” 与 “原函数的极小点” 不符，甚至使目标函数值上升（迭代发散）。）
   - 信赖区域方法通过限制步长，强制每一步的近似模型在 “有效范围内”，从而兼顾局部收敛速度（利用二阶信息）和全局稳定性（避免近似失效）。
   - 那么如何确定这个信赖区域的范围呢？一个比较好的方法是根据我们的近似模型跟实际函数之间的差异来确定：如果差异小，说明近似效果好，我们扩大近似的范围；反之，如果差异大，就缩小近似的范围。我们定义一个指标 ρ （实际差值比上预测差值）来刻画近似的好坏程度。ρ 的分子是实际函数下降的值，分母是近似模型下降的值。如果 ρ 接近于 1，则近似是好的。如果 ρ太小，说明实际减小的值远少于近似减小的值，则认为近似比较差，需要缩小近似范围。反之，如果 ρ 比较大，则说明实际下降的比预计的更大，我们可以放大近似范围。
<br>https://blog.csdn.net/suoxd123/article/details/150641700
  - 当问题性质较好的时候选择高斯牛顿法，否则选择LM算法。
  - **上面的算法我认为都容易陷入局部最优的问题**可采用多初值（multi-start）方法选多个随机初值，多次迭代，取最小值简单有效算力多。或者使用凸优化，如果能把问题转成凸问题，全局最优唯一高效需要结构良好。对于非凸函数，可以限定在凸区域，加上正则项使其凸化，或用全局+局部的混合策略。
  - **优化库**
  - ceres库：自动化处理该问题的求解流程—— 无需手动推导雅可比矩阵、构建稀疏系统，只需定义 “残差如何计算”，库会自动完成求导、求解器配置、迭代优化等工作。
  - g2o库：
    - **图优化** 把优化问题表现成图的一种方式，一个图由若干个定点和连接着顶点的边构成，进而用顶点表示优化变量，用边表示误差项。用 “图的节点” 表示待优化的变量（如机器人位姿、路标点），用 “图的边” 表示变量之间的约束关系（如传感器观测、运动里程计），最终通过最小化所有约束的 “误差总和”，得到变量的最优解。<br>
    - 1、图：普通图的边只能连接 两个顶点。而在超图中，一条边（称为“超边”）可以同时连接 多个顶点。边就是顶点之间的关系。
    - 2、优化：我们希望找到一个 x，使得预测的观测 h(x) 和实际观测 z 的误差最小
    - <img width="189" height="93" alt="图片" src="https://github.com/user-attachments/assets/9a83c90f-25f9-4c0c-9ef9-f4e8bc6a53cd" />
假设机器人当前位姿（状态）是：xk这是我们要估计的“真实位置”和“朝向”，所以 它是未知的。我们通过运动方程获得。
    - 3、怎么把SLAM问题表示成图：在图中，以顶点表示优化变量，以边表示z。
    - 4、图优化：<img width="303" height="75" alt="图片" src="https://github.com/user-attachments/assets/055fb40a-90cc-4989-90bc-d47c20d444eb" />
<img width="467" height="282" alt="图片" src="https://github.com/user-attachments/assets/f1ef5a97-6a05-47eb-ba36-c8cd35ff1c78" />
<img width="613" height="645" alt="图片" src="https://github.com/user-attachments/assets/b71134b1-f417-4892-92d7-15efd8f2a5df" />

   <br> 信息读取-视觉里程计-后段优化-建图（回环检测）
  - **视觉里程计**
  - https://chatgpt.com/c/68f1edb4-9ed8-8324-a4c6-08f06760afba
    -  视觉里程计的核心问题是如何根据图像估计相机运动，给后端提供良好初值。方法有特征点法和直接法。**视觉里程计的目标：用相邻帧（或多帧）相机图像估计相机在空间中的相对运动（即位姿变化），并逐步得到相机轨迹（里程计）。**
    -  特征法：先提取图像中的关键点（如 ORB、SIFT、FAST+BRIEF 等），并计算描述子。在相邻帧之间匹配特征点对。再用匹配点的几何关系（对极几何、PnP、BA）估计相机运动。
    -  优点 ✅鲁棒性强：特征点抗光照变化、尺度变化、旋转，适应场景差异大。数据压缩：只用稀疏特征点，计算量相对较小。匹配直观：特征点可以直接用于回环检测、地图重定位（因为描述子可比对）。工业界成熟：像 ORB-SLAM 系列，已经工程化很好。缺点 ❌信息利用率低：只用了部分像素（特征点），丢掉了大部分图像信息。特征依赖性强：在纹理少、重复纹理的场景（白墙、走廊）会失败。特征提取+匹配耗时：尤其在高分辨率图像中，速度可能跟不上实时要求。
    -  直接法：不提取特征点，直接利用图像所有像素的灰度值。假设亮度一致性，通过最小化光度误差来优化相机位姿。
    -  优点 ✅利用率高：几乎用到了所有像素，能在低纹理场景下也工作。不依赖特征匹配：避免了特征检测失败的问题。高精度：因为使用更多信息，位姿估计精度一般高于稀疏特征法。稠密/半稠密建图自然衔接：可以直接输出深度图或稠密点云（如 LSD-SLAM, DSO）。缺点 ❌计算量大：要优化整个图像区域的光度误差，对硬件要求高。对光照变化敏感：亮度一致性假设在现实中往往不成立（阴影、曝光变化）。需要初始化深度：通常要结合多视图几何或深度传感器。数值不稳定：大视差、动态物体时容易收敛到错误解。
<br>**一、特征点法**：特征点（图像中一些特别的地方，具有明显区分度的点，容易被检测和重复定位。比如说角点、边缘、区块。角点提取算法有：Harris.FAST.GFTT角点算法。人工设计特征点：可重复区别，高效率本地性：SIFT SURF ORB算法）由关键点和描述子(用于描述特征点周围图像区域的数值向量。)两部分组成，**只要两个特征点的描述子再空间上的距离相近，就可以认为他们是同样的特征点。** 找描述子之间的汉明距离：汉明距离用来衡量 两个二进制串（0/1串）之间有多少位不同。
    - **ORB特征**：Oriented FAST and Rotated BRIEF  ，把 FAST 角点检测 和 BRIEF 描述子 结合起来，并加上了方向信息和旋转不变性改进。
    - 也就是说，它在两个经典算法上分别做了改进：FAST → Oriented FAST：让特征点具有“方向性”和“尺度不变性”；BRIEF → Rotated BRIEF：让特征描述子具有“旋转不变性”。
    - (1) 特征点检测 —— Oriented FAST是一种改进的FAST角点。
    - FAST原理：比较像素亮度之间的差异，和相邻像素差异大的认为是特征点。方法：选取像素点，选取半径圆上的像素点，连续几个亮度大于I，就认为是像素点。
    - 为什么FAST检测的是一个圆环而不是一个完整圆？1、但 FAST 的目标就是：
“Features from Accelerated Segment Test”——强调的是 Accelerated（加速）。
所以它只选择：半径固定（比如 3 像素）；离中心点等距离的 16 个像素；这些像素的相对位置是固定的，可以预先计算好坐标偏移；比较亮度差异只需要 16 次简单比较 ➝ 极快。2、圆环正好起到了“多方向采样”的作用。
    - ORB FAST- 解决了不具有方向性和尺度的问题。尺度用图像金字塔解决，匹配不同层上的图像；FAST 角点检测虽然能找出位置（像素点在哪里），
但它不知道这个角点 “朝哪边”。因此旋转方向，通过计算特征点附近灰度质心，几何中心和质心之间连线获得方向。
    - (2) 描述子 。描述子是一个 对关键点周围局部区域外观的数学描述。在特征点邻域里随机挑像素对，比较它们的灰度大小，把结果编码成 0/1。
    - BRIEF 描述子 (Binary Robust Independent Elementary Features)：利用附近两个随机像素之间的大小关系，通过在特征点邻域做简单的像素对比，得到一串二进制描述子。匹配时只需计算汉明距离，速度非常快。
    - Rotated BRIEF：ORB 对 BRIEF 进行了改进：加入旋转校正（Rotated），使其在图像旋转时仍然稳定。根据特征点的方向 θ，对 BRIEF 的采样模板进行旋转；然后再在旋转后的邻域内进行像素比较。
- **计算相机运动**
    - <img width="707" height="247" alt="图片" src="https://github.com/user-attachments/assets/be1b5a73-bdee-4f6a-bc70-f01def7f375f" />
    <br> 两点之间**1.对极约束**
    - 1、几何图片：左右两个相机中心点O，观测目标P点：
    - <img width="439" height="213" alt="图片" src="https://github.com/user-attachments/assets/afe056e4-157e-4c3f-ba95-a447fef3513e" />
    - 2、进行归一化相平面坐标：去除相机内参的影响（减去坐标原点并处以深度）：
    - <img width="377" height="212" alt="图片" src="https://github.com/user-attachments/assets/dd39794a-5490-497d-8bd1-1206f23d17a6" /><br>
    - 3、推导对极约束公式
    - 三维点X在两个相机坐标系中的位置关系是：X2=R X1+t。都移到一侧，t,Rx1,x2三个向量共面。
如果三个向量共面，那么它们的混合积（triple product）为 0：x2T[t]×Rx1=0。E=[t]×R称为 本质矩阵（Essential Matrix）于是对极约束就变成非常简洁的一句：x2TEx1=0。
      <br>所以相机位姿估计变成：1、求E、F2、根据EF求R\t。由于旋转和平移各有3个自由度，所以E共有6个自由度，由于尺度等价性，所以只有5个自由度。尺度等价性:对极约束是等式为0的约束，乘以任意常数依旧为0.因此虽然可以用5个点对进行计算。
      <br>但是我们常用八点法：只考虑了尺度的等价性，用8个点对来估计E。
      <br>**然后**通过过八个公式解出了本质矩阵E，截下来通过奇异值分解恢复相机的运动R、t。**矩阵SVD分解**SVD = 旋转 → 缩放 → 旋转。只是会有多个解，需要带入确定，因为没有深度。
      <br>单应矩阵：H描述了两个平面之间的映射关系，计算机视觉领域中描述两个平面之间投影变换关系的核心工具。<img width="724" height="379" alt="image" src="https://github.com/user-attachments/assets/e97efd8b-9149-4298-98f5-2f9dcd30d14c" />
   <br>**2.三角测量**
     - 完成对极约束后，通过三角测量恢复图像深度Z。
     - 3D-2D**PNP**
     - 当你指导你已经知道一些 三维点（世界坐标系）：Pi=(Xi,Yi,Zi)​你也知道这些点在图像上对应的 二维像素坐标：pi=(ui,vi)还知道相机的 内参矩阵 K，由此去求解相机姿态变换。
     - 有 3 个点时，称为 P3P（最小解）；有 4 个以上点时，一般用线性或迭代方法：DLT；有很多点时，用最小二乘法拟合最佳位姿：BA。
     - 1、DLT利用6对匹配点实现增广矩阵矩阵T的求解。<img width="563" height="565" alt="图片" src="https://github.com/user-attachments/assets/de3ac5dc-9713-46e1-8189-7a438d3203f9" />
     - 2、P3P 利用三角形的相似关系获得，通过 3 对 3D–2D 点匹配 解析求相机位姿的算法。
     - 3、BA 最小化重投影误差求PNP 把相机和三维点放在一起进行最小化重投影误差。BA(bundle adjustment)指的是同时调整相机姿态和特征点位置，以便从每个特征点反射出的光线(bundles of light rays)，通过调整(adjustment)最后都能通过相机光心。BA通常构建为一个最小二乘问题，通过使重投影误差最小化来同时调整相机的位姿和特征点的坐标。
     - 1.重投影： 重投影顾名思义就是把 3d空间中的点重新投影到图像平面上。根据重投影求得的3d点理论像素坐标和我们的观测到的像素坐标必然不同，而这个理论值和观测值的差就是重投影误差。针对于我们可以构建最小二乘问题，通过调整 来使重投影误差的平方和(因为误差有正有负，所以取平方) 最小化。我们需要做的就是求解出误差平方和的梯度，然后按梯度下降方向迭代，直至收敛。
     - 我们把第一帧固定,设定为世界坐标系原点(即该帧相机的旋转为单位矩阵 ,位移为0向量),同时优化3D点的空间位置和第二帧的姿态。针对于两帧之间的BA，我们要求解目标函数:、
       <img width="238" height="84" alt="image" src="https://github.com/user-attachments/assets/0a73fa33-9068-4a45-9883-7e1783742691" /><br>
       其中,  为我们优化位姿的李代数表示(因为我们要求解的是两帧之间的PNP问题，并且我们固定了第一帧的姿态)，P为第一帧和第二帧共同观测到的特征点坐标，我们假设在两帧图片上共匹配了m个特征点。使用李代数表示姿态的原因是，只有单位正交阵才能表示旋转，如果使用矩阵，那么就会构建出一个带有约束的优化问题。而通过李群-李代数的转换关系，正好可以把BA构建成无约束优化，简化求解。

     - 3D-3D**ICP**
     SVD与非线性优化进行求解。
<br>**二、直接法**
     - 特征法：1、耗时2、丢弃信息3、特征缺失情况下无足够匹配点
     - 2D光流：直接法是由光流演变而来，光流是一种描述像素随着时间在图像之间运动的方法，计算部分运动称为稀疏光流，所有像素称为稠密光流。
         - LK光流： 1、灰度不变假设 2、某一窗口内像素会具有相同地运动
         - 多层光流：两张图片差异明显，陷入局部最小值，引入图像金字塔解决。图像金字塔是指对同一个图像进行缩放，得到不同分辨率下的图像，原始图像作为金字塔底层，计算光流时从顶层开始计算，把上一层的结果作为下一层的初值。
     - 1、光流法：保留特征点，只计算关键点不计算描述子，利用光流跟踪特征点运动。
         - 把特征点匹配换成光流跟踪，估计相机运动依旧使用对极几何、ICP等。只是特征点不要求是角点，可以是随机选取。  所以稀疏光流需要特征点，但不需要像传统匹配那样在整个图像中搜索对应点，在连续帧之间跟踪这些特征点的位置，得到每个点的 XY 速度（LK光流）。稠密光流不需要特征点，直接用亮度信息计算像素位移。
     - 2、直接法：只计算关键点不计算描述子，利用直接法计算特征点在下一时刻图像的位置。跳过了描述子计算，省去了光流。
         - ⭕上面是考虑特征点位置，然后在确定相机运动，但是我们希望再后一步中去调整前一步的结果。现在考虑P点的世界坐标和在相机上的成像p1,p2。根据投影方程：<img width="377" height="279" alt="图片" src="https://github.com/user-attachments/assets/fed5074b-9d47-4f52-bebf-7ce04aeec4d3" />
         - ⭕特征点可以计算重投影误差，这里我们没有匹配特征点，不知道p2对应哪个p1,因此思路为根据当前位姿寻找p2.优化**光度误差**。<img width="175" height="47" alt="图片" src="https://github.com/user-attachments/assets/fc04b0ec-8f54-4a2d-982e-10703ce7a3a3" />
         - ⭕对上面这个利用二范数进行优化，有许多个空间点Pi,问题转化为<img width="405" height="59" alt="图片" src="https://github.com/user-attachments/assets/77ededcb-c5f9-4400-bad3-a185cbe86b0e" />
         - ⭕分析导数关系进行优化。
<img width="693" height="638" alt="图片" src="https://github.com/user-attachments/assets/9a70b136-4c61-49bc-a34d-e435458ee994" />
<img width="693" height="638" alt="图片" src="https://github.com/user-attachments/assets/6c322a6f-43e1-4d10-8c61-f2d05c3cb7b7" />
     - 2.2、稀疏直接法：P点来源于稀疏关键点、半稠密直接法：P点来自部分像素、稠密直接法：P点来源于所有像素。
       优缺点：优点：不依赖特征点，低纹理区域可用、利用像素灰度信息，精度高、可做稠密或半稠密建图、缺点：对光照变化敏感、对快速运动或遮挡不鲁棒、计算量大，需良好初值。<br>
<br>**后端**<br>
前端视觉里程计给出了一个短时间内的轨迹和地图，但由于不可避免的误差累积，这个地图在长时间内是不准确的。所以，在视觉里程计基础上，我们还希望构建一个尺度、规模更大的优化问题，以考虑长时间内的最优轨迹和地图。<br>
在后端优化中，我们通常考虑一段更长时间内的状态估计问题，而且不仅使用过去的信息更新自己的状态，也会用未来的信息来更新，这种处理方式成为“批量式Batch”。否则，如果当前的状态只由过去的时刻决定，甚至只由前一个时刻决定，则称为“渐进式Incremental”。<br>
“前端的核心工作就是实现 VO”。它的本质是 “从连续图像帧中，通过视觉信息计算机器人 / 相机的局部相对位姿，为后端提供初始的状态约束”，是连接原始视觉数据和后端全局优化的 “桥梁”。VO 不关心全局状态，只计算 “相邻帧” 或 “短序列帧” 之间的相对位姿（比如帧 i 到帧 i+1 的位姿变换 T_ii+1），以及特征点对应的 “初步路标位置”。这些结果会作为 “初始约束” 传给后端，后端再基于这些约束做全局优化 —— 这正是 “前端生成局部信息，后端处理全局信息” 的分工逻辑。<br>
后端本质上就是基于概率的状态估计，它的核心设计和工作逻辑都围绕 “用概率模型处理状态不确定性” 展开，只是不同后端对概率的 “显式 / 隐式” 处理方式略有差异。<br>
后端的核心目标是解决前端带来的噪声和漂移问题，而概率状态估计正是实现这一目标的核心工具。<br>
1、状态不是 “一个数”，而是 “可能性分布”，<br>
比如机器人位姿（x,y,θ），因为传感器噪声（相机模糊、激光干扰），它不可能是精确的（1,2,30°），而是 “在（1,2,30°）附近的一片区域”—— 这片区域就用高斯分布描述。<br>
2、只需要存两个关键信息：均值和协方差<br>
均值：状态的 “最优估计值”，比如（1.02, 1.98, 29.9°），是我们认为最可能的位姿 / 路标位置。
协方差矩阵：状态的 “不确定性度量”，比如 x 方向的协方差大，说明 x 坐标的估计很不靠谱；x 和 y 的协方差为正，说明 x 偏大时 y 也可能偏大。<br>
3、核心任务：用数据更新 “均值和协方差”<br>
当有新的运动数据（比如轮子里程计说 “走了 1 米”）或观测数据（比如相机看到了某个路标）时，就用数学方法（如卡尔曼滤波、贝叶斯公式）调整均值（让估计更准）和协方差（让不确定性变小）。<br>
提到批量状态估计问题可以转换为最大似然估计问题，并使用最小二乘法进行求解。<br>
    - **贝叶斯公式**
<img width="601" height="156" alt="图片" src="https://github.com/user-attachments/assets/a162de65-6bf4-4d2b-b555-5acf02b152f2" />
    - 现在考虑第k时刻的情况。我们希望用过去0到k时刻期间的数据来估计现在的状态分布：P(xk|x0,u0:k,z1:K)下标0表示从0时刻到k时刻的所有数据。请注意， zk表示所有在k时刻的观测数据，它可能不止一个，只是这种记法更方便。同时，xk实际上和xk-1，xk-1 这些量都有关，但是此式没有显式地将它们写出来。
<br>上式最右侧，第一项为似然分布（likelihood distribution），第二项为先验分布（prior distribution）。似然分布由观测方程给定，而先验分布部分，我们要明白当前状态xk是基于过去所有的状态估计得来的。
<br>似然项表示：如果系统状态是 𝑥𝑘，那么观测 𝑧𝑘出现的可能性。**这个是用来进行修正预测的部分**先验项:表示：在看到第𝑘个观测之前，根据之前所有信息我们预测当前状态的概率。**这个是用来预测的**
<br>**上面这一部分是用来更新的，因为利用了修正**
<br>至少，它会受xk-1影响，于是以xk-1时刻为条件概率展开：
<img width="760" height="126" alt="图片" src="https://github.com/user-attachments/assets/585a75d9-c599-4b60-8a3a-6fdf70f1e4df" />
<br>这个式子是在计算上面的“先验项”。当前状态的预测概率 = 上一时刻状态的后验概率 × 状态转移模型，对上一状态积分。是的，第一个是状态转移矩阵，第二个是上一时刻的后验概率。
<br>**上面这部分是进行预测的**
<br>至此，我们给出了贝叶斯估计，因为上式还没有具体的概率分布形似，所以没法实际操作它。对这一步的后续处理，方法上产生了一些分歧。大体上讲，存在下面两种选择：
     - 1、**马尔可夫性**：简单的一阶马氏性认为，k时刻的状态只和k-1时刻有关，我们会获得扩展卡尔曼滤波（EKF）为代表的滤波器方法。
         - 1、线性系统 KF
         - 上面状态转移矩阵转化成：P(xk​∣xk−1​,uk​)，当前状态 𝑥𝑘只与前一时刻状态 𝑥𝑘−1有关，与更早的状态 𝑥0,𝑥1无关。而且，在状态转移时刻，系统的控制输入𝑢𝑘是外部已知的影响量。而且没有Z，只需要知道上一个状态和当前控制量就够了，之前的历史信息不会再直接影响当前状态。
         - 上面上一时刻的式子转化成：P(xk−1​∣x0​,u1:k​,z1:k−1​)=P(xk−1​∣x0​,u1:k−1​,z1:k−1​)，预测上一步的状态时，只需要之前的控制量和观测，不可能受到未来的输入影响。
         - 计算后验概率：https://chatgpt.com/s/t_68f99d8c40848191b1bb6e8e8c82b979 通过这个式子获得卡尔曼增益K，让背后获得更新后的概率和情况。
     - 2、考虑k时刻和前面所有状态之间的关系，获得以**非线性优化**为主题的优化框架。
         - **非线性系统和EKF** 因为一般情况下运动和观测方程都是非线性函数，一个高斯函数经过非线性变化后也不再是一个高斯分布。
         - 做法是：运动方程和观测方程一阶泰勒展开，只保留一阶项，然后按照线性系统进行推导，
         - EKF局限：1、在一定程度上假设马尔可夫性，无法处理和很久之前相关的数据。2、非线性误差：仅仅做了一次线性化，不一定能够近似整个函数。3、不适合大型场景，储存均值方差，数据量大。4、没有异常值检测机制。

     



 


















































        
 



