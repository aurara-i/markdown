
 Linux 系统的目录结构遵循（Filesystem Hierarchy Standard，文件系统层次结构标准），所有目录都从根目录开始，形成一个树状结构。这种统一的结构让不同 Linux 发行版（如 Ubuntu、CentOS、Debian 等）的目录布局保持一致，方便用户和程序定位文件。
## 核心目录及其功能
### 1. 系统基础与启动相关
- **`/`（根目录）**  
  整个文件系统的起点，所有目录和文件都挂载在根目录下。

- **`/boot`**  
  存放系统启动必需的文件，包括 Linux 内核（`vmlinuz`）、引导加载程序（如 GRUB 的配置文件 `grub.cfg`）、启动镜像等。系统启动时，BIOS/UEFI 会从这里加载内核。

- **`/sbin`**  
  存放**系统管理命令**，仅 root 用户（超级管理员）常用，用于系统维护，如 `reboot`（重启）、`fdisk`（磁盘分区）、`ifconfig`（网络配置，部分发行版已被 `ip` 替代）等。
### 2. 系统配置与核心文件
- **`/etc`**  
  存放**系统和应用程序的配置文件**，是 Linux 中最常用的目录之一。例如：  
  - 网络配置：`/etc/network/interfaces`（网络接口配置）、`/etc/resolv.conf`（DNS 服务器）；  
  - 用户配置：`/etc/passwd`（用户账户信息）、`/etc/group`（用户组信息）；  
  - 服务配置：`/etc/systemd/system`（systemd 服务配置）、`/etc/nginx`（Nginx 服务器配置）。

- **`/lib` 与 `/lib64`**  
  存放系统运行必需的**共享库文件**（类似 Windows 的 DLL 文件）和内核模块（`.ko`）。  
  - `lib` 对应 32 位系统或 64 位系统的兼容库；  
  - `lib64` 仅在 64 位系统中存在，存放 64 位库文件。
### 3. 设备与虚拟文件系统
- **`/dev`**  
  存放**设备文件**（Linux 中“一切皆文件”，硬件设备通过文件抽象）。例如：  
  - 硬盘：`/dev/sda`（第一块 SATA 硬盘）、`/dev/nvme0n1`（第一块 NVMe 硬盘）；  
  - 终端：`/dev/tty1`（第一个虚拟终端）；  
  - 光驱：`/dev/cdrom`。

- **`/proc`**  
  虚拟文件系统（不占用磁盘空间，数据存于内存），反映**系统实时状态**。例如：  
  - 进程信息：`/proc/1234`（PID 为 1234 的进程详情）；  
  - 系统资源：`/proc/meminfo`（内存使用情况）、`/proc/cpuinfo`（CPU 信息）。

- **`/sys`**  
  虚拟文件系统，主要用于**硬件设备的配置与状态查询**，比 `/proc` 更侧重硬件细节。例如：`/sys/class/net`（网络接口信息）、`/sys/devices`（设备树）。


### 4. 用户与应用相关
- **`/home`**  
  普通用户的**家目录**，每个用户在这里有独立的子目录（如 `/home/zhang`、`/home/lisi`），用于存放用户的个人文件（文档、下载、配置等）。
- **`/root`**  
  超级管理员（root 用户）的家目录，与普通用户的 `/home` 分开，权限更高。
- **`/bin`**  
  存放**基础用户命令**，所有用户均可访问，且系统启动时就需要这些命令（如 `ls` 列表、`cp` 复制、`mkdir` 创建目录等）。
- **`/usr`**  
  存放“用户可共享的程序和数据”，是系统中最大的目录之一，内部结构类似根目录：  
  - `usr/bin`：非启动必需的用户命令（如 `gcc` 编译器、`python` 解释器）；  
  - `usr/sbin`：非启动必需的系统命令（如 `apache2` 服务器启动命令）；  
  - `usr/lib`：应用程序的库文件；  
  - `usr/share`：共享数据（如文档、图标、字体等）；  
  - `usr/local`：用户手动安装的软件（如源码编译的程序，避免与系统自带软件冲突）。
- **`/opt`**  
  存放**第三方可选应用**（通常是大型软件），如 Oracle 数据库、Matlab 等，方便集中管理和卸载。

### 5. 临时与可变数据
- **`/tmp`**  
  临时文件目录，所有用户可读写，系统会定期自动清理（或重启后清空），适合存放临时缓存、日志等。

- **`/var`**  
  存放**“可变数据”**（内容随系统运行动态变化）：  
  - `var/log`：系统和应用程序的日志文件（如 `syslog` 系统日志、`auth.log` 登录日志）；  
  - `var/cache`：应用程序的缓存（如浏览器缓存、软件包缓存）；  
  - `var/mail`：用户邮件；  
  - `var/spool`：队列数据（如打印任务、定时任务）。


### 6. 外部存储挂载
- **`/mnt`**  
  手动挂载外部存储设备（如 U 盘、移动硬盘、网络共享目录）的临时挂载点，例如 `mount /dev/sdb1 /mnt/usb` 可将 U 盘挂载到 `/mnt/usb`。

 - **`/media`**  
  自动挂载外部设备的目录（现代 Linux 发行版常用），插入 U 盘或光盘时，系统会自动在 `/media/用户名/设备名` 下创建挂载点。


## 总结
Linux 目录结构的设计遵循“功能分离”原则：系统文件与用户文件分离、静态文件（如程序）与动态文件（如日志）分离、必需文件与可选文件分离。理解这些目录的作用，能帮助你快速定位文件、排查问题（如日志在 `/var/log`，配置在 `/etc`），是使用 Linux 的基础。
## linux中ubuntu安装软件操作
### 通过APT安装包安装
- sudo apt update
- sudo apt install firefox
- sudo apt remove firefox
- sudo apt upgrade  # 升级所有可更新的软件
- sudo apt upgrade firefox  # 仅升级指定软件
- apt search [关键词]  # 例如查找 "编辑器" 相关软件：apt search editor
### 源码编译安装
安装编译工具（首次编译需执行）：
- bash
- sudo apt install build-essential  # 包含 gcc、make 等基础编译工具
下载并解压源码包：
例如下载 example-1.0.tar.gz 后，在终端解压：
- bash
- tar -zxvf example-1.0.tar.gz  # 解压 gz 格式
- cd example-1.0  # 进入解压后的目录
配置编译参数：
大多数源码包会提供 configure 脚本，用于检查依赖并生成 Makefile：
- bash
./configure  # 可添加参数，如指定安装路径：./configure --prefix=/usr/local
编译源码：
- bash
- make  # 编译过程可能耗时，取决于软件复杂度
安装编译好的软件：
- bash
- sudo make install
卸载源码安装的软件（需在源码目录执行）：
- bash
- sudo make uninstall


# 视觉SLAM 
## 定位和建图
### 传感器
- 机器人：轮式编码器、相机、激光、imu
- 环境：导轨、二维码标志
### 相机
 拍摄的图像需要恢复三维结构，恢复相机的运动和远近大小。
 单目相机通过视差可以定量的判断远近，但是存在尺度不确定性。
 双目相机可以获得尺度信息，但是计算量大。深度相机适合室内。
### SLAM框架
![](https://github.com/aurara-i/markdown/blob/main/picture/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-04%20185108.png)
- 前端视觉里程计：估算相邻图像之间相机运动。每次估计会存在偏差，因此会存在累积飘移，因此需要进行后端优化和回环检测。（计算机领域）
- 后端优化：接受相机位姿和回环检测进行优化。主要就是处理噪声问题。（滤波与非线性优化）
- 回环检测：判断机器人是否到达过先前的位置，如果检测到回环提供给后端。解决为位置随时间飘移问题。
### 数学表达
- 运动：轨迹由离散的时间k和离散时间的位置xk构成。用运动方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/3.png)
  u为观测量，w为噪声。
- 观测：观测在k时刻处于xk位置观测到地图上路标yk。用观测方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/4.png)  
  v为噪声。
上述通过两个方程，通过运动观测u和传感器读数Z解决定位问题（x）和建图(y)问题。 建模为状态估计问题：线性/非线性，高斯/非高斯。
其中线性高斯系统的无偏最优估计可以由卡尔曼滤波获得。（预测与更新）我觉得上面的运动就是状态矩阵，观测就是更新矩阵。
而目前主要使用图优化进行状态估计。
### Kalman Filter（https://blog.csdn.net/qq_37214693/article/details/130927283?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&utm_relevant_index=2）
  - 卡尔曼滤波的原理是赋予权重，判断哪个信息的可信度高，可信度高的就赋予更高的权重，可信度低的赋予权重低，由此获得最优估计。
  - 基于状态信息的运动方程获得先验状态矩阵，传感器量测到的状态值获得状态观测矩阵。两者结合处理后获得后验状态矩阵。最优估计为其中心。
- 1、状态方程 xₖ = Fₖxₖ₋₁ + Bₖuₖ + wₖ
  - xₖ	时刻 k 的 “状态向量”	，Fₖxₖ₋₁	前一时刻状态对当前的影响	，Bₖuₖ	输入信号对当前状态的影响	，wₖ	过程噪声（随机变量）	，cov{wₖ}=Qₖ	噪声的协方差矩阵
- 2、观测方程 zₖ = Hₖxₖ + vₖ
  -zₖ	时刻 k 的 “观测向量”	，Hₖxₖ	状态对观测的 “理想映射”	，vₖ	观测噪声（随机变量），cov{vₖ}=Rₖ	观测噪声的协方差矩阵	
#### 是先通过状态方程 “预测” 当前状态，再用观测方程的实际测量结果 “校正” 这个预测值，最终得到更接近真实状态的估计值。如果发现预测的状态偏了就进行修正。若观测噪声 vₖ小（GPS 精度高，Rₖ小），就 “多信观测”，让修正后的状态更靠近 zₖ；若过程噪声 wₖ小（状态预测准，Qₖ小），就 “多信预测”，少修正一点。
![](https://github.com/aurara-i/markdown/blob/main/picture/5.png)
- 3、状态估计误差 \(\tilde{x}_{k|k - 1} = x_k - \hat{x}_{k|k - 1}\) 
  - x_k：k 时刻系统的真实状态。这是客观存在的物理量，但无法直接获取（只能通过估计逼近）。
  - k-1 时刻对 k 时刻状态的预测估计值
  -k 时刻的预测误差（也称 “先验误差”），即 “真实状态与预测估计值的偏差”。
- 4、状态估计方程 
  - 利用 k-1 时刻的最优状态估计和 k 时刻的控制输入，预测 k 时刻的状态
- 5、观测估计误差 
- 6、观测估计方程
####  这里的估计，不包含随机且不确定的误差。卡尔曼滤波通过 “先做无噪声的理想预测，后续再用噪声的统计特性（协方差）修正” 的两步法，间接处理了噪声的影响，既保证了估计的 “基础逻辑简洁性”，又能通过统计方法实现 “最优修正”。
- 7、状态误差协方差矩阵 
- ![](https://github.com/aurara-i/markdown/blob/main/picture/6.png)
- 8、观测误差协方差矩阵
- 9、 迭代估计表达式  \(\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k \tilde{e}_k\) 
 #### 这里的K就是卡尔曼增益。因此，我们需要推导出所用变量的迭代式，并求得卡尔曼增益。这是核心权重。如果 “猜测的观测” 很不准，或 “观测噪声” 很准，增益  就大（更信观测）；反之则小（更信猜测）。
-后验估计
-  ![](https://github.com/aurara-i/markdown/blob/main/picture/7.png)
 ####  状态估计误差：下标 (k|k-1) 的含义是k 时刻的状态，基于k-1 时刻的信息进行估计”。因为 k-1 时刻时，k 时刻还未到来，只能预测未来（用过去的信息猜未来的状态），所以用 “(k|k-1)” 明确 “估计的时间逻辑”——“基于过去，估计未来”。而观测估计误差下标 k 的含义是 “k 时刻的观测”。因为观测 (z_k) 是k 时刻实时获取的测量值（比如 GPS 在 k 时刻的读数），误差直接对应 “当前时刻（k）的观测”，所以用简洁的 k 表示 “这是 k 时刻的观测相关误差”。
![](https://github.com/aurara-i/markdown/blob/main/picture/8.png)
## G++编译器
- `g++ helloslam.cpp`生成./a.out的可执行文件，在终端中输入这个可执行文件就可以成功运行。
## CMAKE基础
 - 这确实是我第一次真正生成Cmake。值的记录！！
  - 新建并在CMakeLists.txt中写
  - **` cmake_minimum_required(VERSION 3.10)#声明的要求最低版本CMake `**
  - **` project(Untitled-1)#声明工程 `**
  - **` add_executable(Untitled-1 Untitled-1.cpp)#添加可执行程序（程序名 源代码文件）`**
   - 然后在终端输入cmake . 就会生成一些中间文件。
   - 再输入make进行编译
 - 编译成功后输入：./Untitled-1 可执行程序就能够执行了,输出helllo slam!
 - 所以如果想要新增一个可执行文件，只需要再添加一行就行。
 - 我们希望生成的中间文件不要放在代码目录中，新建一个build目录然后进行Cmake和make
 -  **如何生成库**
 - 我们自己生成库，在cmakelist.txt中增加：add_library( .cpp),然后和上面一样cmake编译就行。生成的.a文件就是想要的库。
 - 还需要一个头文件才能够调用库。头文件包括宏定义和函数名
 - 然后在cmakelist中增加可执行程序的生成命令连接到库上，target_link_libraries()
## 三维刚体运动 
 - **内积**  内积是描述向量之间的投影关系。
 - **外积**  外积的结果是一个向量，方向垂直于这两个向量，是两个向量张成的四边形的有向面积。向量叉乘 a×b 的结果可以通过将向量 a 转化为反对称矩阵 a∧ 后与向量 b 做矩阵乘法。

 - 如图，把外积写成了矩阵与向量的乘法，变成了线性运算。任意向量都唯一对应一个反对称矩阵。
- **刚体运动** 运动过程中向量大小不会发生变化。
- **欧式变换** 导航坐标系和世界坐标系之间差了一个欧式变换，欧式变换由旋转和平移构成。
- **旋转矩阵（方向余弦矩阵）** R12 表示把坐标系2的向量变换到1中。求逆表示反向的旋转。

- 如图，旋转矩阵来源。
- 对于**旋转矩阵的实践**，我们主要使用EIGEIN库进行矩阵的计算。这个库是由纯头文件构成，无需连接库文件，只需引入头文件即可。
- **Eigien库矩阵的使用**
- 所以在CMakeLists.txt中 include_directories( "/usr/include/eigen3" )
    -- **可以省略的情况：**
    Eigen 是纯头文件库，若其安装路径在系统默认的头文件搜索路径中（如 Linux 的/usr/include、/usr/local/include，或通过包管理器安装时自动配置的路径），CMake 会自动找到它，无需手动指定。
    -- **必须保留的情况：**
    若 Eigen 安装在非默认路径（如自定义目录、Windows 系统中手动解压的路径），则必须通过这行指定头文件位置，否则编译时会提示 “找不到 Eigen 头文件”。
- `Eigein::Matrix<double ,3 ,3> Matrix3d;`//三维矩阵原始定义
- `Eigein::Matrix3d matrix3d=Eigein::Matrix3d::Zero()`//内置的三维矩阵直接调用，可初始化为0
- `Eigein::Matrix<double,Eigein::Dynamic,Eigein::Dynamic> Matrixnd`//矩阵大小动态设置
- `matrix3d=1,2,3,4,5,6,7,8,9;`//三维矩阵初始化
- `cout<<matrix3d;`//进行输出
- `for（int i=0；i<3;i++） for(int j=0;j<3;j++) cout<<matrix3d(i,j)`//访问特定元素
- `.transpose 转置 .trace 迹 .inverse 逆 .determinant行列式`
- `Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> eigen_solver ( matrix_33.transpose()*matrix_33 );`//使用 Eigen 库中的SelfAdjointEigenSolver类来求解一个 3x3 矩阵的特征值和特征向量
    - matrix_33.transpose() * matrix_33
    对原始矩阵matrix_33做转置（.transpose()）后，再与自身相乘。
    数学意义：这样得到的新矩阵一定是对称矩阵（满足A^T = A），且是半正定的（特征值非负）。
    - Eigen::SelfAdjointEigenSolver<...>
    这是 Eigen 中专门用于求解对称矩阵特征值和特征向量的工具类（SelfAdjoint表示 “自伴随”，即对称矩阵）。
    - `eigen_solver`
    是实例化的求解器对象，通过它可以获取计算出的特征值和特征向量。
 - 解方程
    - 直接求逆
    - 史密特正交化`x = matrix_NN.colPivHouseholderQr().solve(v_Nd);`
 -**旋转向量与欧拉角**
 - 旋转向量：任何旋转都可以由一个旋转轴和旋转角刻画，我们用一个向量方向和旋转轴一致，长度等于旋转角对旋转刻画。
 - 三维空间中的刚体运动共有六个自由度：三个旋转自由度 + 三个平移自由度；旋转向量可把旋转压缩为三维，平移向量本身是三维，两者拼起来正好六维，能无冗余且完备地描述刚体变换。而上面的旋转矩阵用十六个量表示了六个自由度的变换。 从旋转向量到旋转矩阵的转换过程为**罗德里格斯公式**。
 - 旋转矩阵R是 3×3 矩阵（9 个元素），但它必须满足 **“正交性” 和 “右手坐标系”** 两个核心约束，这会消除 6 个自由度，最终只剩 3 个独立参数。
 - 对于 3×3 矩阵，RTR=I意味着：
    - 每行（或列）都是单位向量（3 个方程）：比如第一行满足r112​+r122​+r132​=1；
    - 不同行（或列）互相垂直（3 个方程）：比如第一行和第二行满足r11​r21​+r12​r22​+r13​r23​=0。
    - 共 6 个方程，每个方程都会减少一个自由度，因此 9 - 6 = 3。
 - 旋转轴是三维空间中的一个单位向量n=(nx​,ny​,nz​)，但 “单位向量” 的约束会减少一个自由度，因此从 3 个参数变成 2 个独立参数。旋转角为一个自由度。
 - **欧拉角**
 - 把旋转等价于三个分离的转角，三次绕不同轴的转动。俯仰、横滚、偏航。存在万向锁的问题，奇异性。同理，上面的旋转向量在180度的时候也会存在奇异性。
 - **四元数**
 - 没有奇异性。q=q0+q1i+q2j+q3k
    -q0​ 是实部，q1​,q2​,q3​ 是虚部（对应三维空间的 3 个维度）；i,j,k 是四元数的虚数单位，满足特殊的乘法规则：i2=j2=k2=−1，ij=k,jk=i,ki=j（右手定则），且乘法不满足交换律（如 ji=−k）。
 - 表示旋转：
   - 旋转四元数的关键约束：**单位四元数**。并非所有四元数都能表示旋转 ——只有 “单位四元数”（模长为 1 的四元数）才能描述旋转。这一约束的本质是：旋转不改变向量的长度，单位四元数的乘法能保证 “长度不变性”（类似旋转矩阵的正交性）。
   - 三维空间的任意旋转，都可唯一分解为 “绕某一固定轴旋转特定角度”（欧拉旋转定理）。四元数正是直接对应这一分解：
   - 若旋转的单位轴向量为 u=[ux​,uy​,uz​]T（∥u∥=1），旋转角为 θ（右手定则：拇指沿 u 正向，四指弯曲方向为旋转方向），则对应的单位四元数为：
   - q=cos(2|θ​)+ux​sin(2|θ​)i+uy​sin(2|θ​)j+uz​sin(2θ​)k
   - 可简化为 “实部 + 虚部向量” 的形式：
   - q=[cos(2θ​),ux​sin(2θ​),uy​sin(2θ​),uz​sin(2θ​)]T
实部表示旋转角度，虚部表示旋转方向。
 -  θ/2 编码能完美匹配现实中的旋转效果 —— 这是因为 θ/2 编码恰好抵消了 “四元数乘法的双线性特性”（数学上，四元数旋转对应 “SU (2) 群”，而 3D 旋转对应 “SO (3) 群”，θ/2 是这两个群同态映射的关键）。
 - **几种旋转之间转换**
 - **旋转变化明天再看把，困死了**
 - 相似变换：旋转、平移、缩放
 - 仿射变换：旋转矩阵不要求正交
 - **Eigein库中旋转的使用**
   - 在 Eigen 中，**AngleAngleAxis** 是一种专门用于表示旋转向量的类，它的底层实现不是矩阵，而是直接存储了 “旋转角度” 和 “旋转轴方向” 这两个核心信息。
   - ` Eigen::AngleAxisd rotation_vector ( M_PI/4, Eigen::Vector3d ( 0,0,1 ) );`
   -  **旋转向量 转 旋转矩阵**
   - `cout<<"rotation matrix =\n"<<rotation_vector.matrix() <<endl;` //直接转为矩阵
   - 也可以`rotation_matrix = rotation_vector.toRotationMatrix();`//或者用这个函数
   - **旋转矩阵 转 欧拉角**
   - `Eigen::Vector3d euler_angles = rotation_matrix.eulerAngles ( 2,1,0 ); // ZYX顺序，即roll pitch yaw顺序`
   - **用旋转向量和旋转矩阵进行坐标变换**
   -  `::Vector3d v ( 1,0,0 );`
   -  `Eigen::Vector3d v_rotated = rotation_vector * v;`
   -  `v_rotated = rotation_matrix * v;`
   -  **欧式变换矩阵**
   -  `Eigen::Isometry3d T = Eigen::Isometry3d::Identity();`
   -  `Isometry3d 是 Eigen 中专门用于表示三维欧氏变换的类（“Isometry” 意为 “等距变换”，即保距变换）。虽然名字带 “3d”，但内部存储的是 4×4 矩阵（因为需要包含平移部分）。`
   -  `T.rotate(rotation_vector);  // 应用之前定义的旋转向量，当然，这里换成其他旋转的表达也是ok的`
   -  `T.pretranslate(Eigen::Vector3d(1,3,4));  // 平移向量 t = (1,3,4)`
   -  也可以直接`Eigen::Vector3d v_transformed = T * v;  // v 是初始向量 (1,0,0)`
   -  这里的 * 运算符是 Eigen 重载的欧氏变换操作，等价于数学上的：vtransformed​=R⋅v+t
即 “先对向量 v 应用旋转 R，再加上平移 t”。
   -  **四元数**
   - `Eigen::Quaterniond q = Eigen::Quaterniond(rotation_vector);`
   - `q = Eigen::Quaterniond(rotation_matrix);`
   - `v_rotated = q * v;  // 数学上等价于 q·v·q⁻¹`//用四元数旋转一个矩阵
  - **可视化演示**
  - **小萝卜的例子**
  - 1、四元数先转的在右侧，我给忘记了。
  - 2、四元数一定要定义完成后归一化。
  - 3、**这里的位姿原来指的是再载体坐标系下的，所以对于旋转向量直接q1q2之间求就可以了。对于位置平移向量，要先把t1转回世界坐标系再转到2。**
<br>**李群李代数**
<br>群：一种集合加一种运算。具有封闭性、结合律、幺元、逆的性质。
<br> 李群：具有连续性质的群。
<br>旋转群 SO (3)：三维空间中绕任意轴的旋转（比如地球自转、方向盘转动）。这些旋转操作满足 “群的 4 条规则”（封闭性：两个旋转叠加还是旋转；结合律：旋转顺序不影响最终结果；单位元：不旋转的 “零操作”；逆元：转 30° 再转 - 30° 回到原位），且旋转角度可以连续从 0° 变到 360°，是典型的李群。
<br>平移群：在平面上把一个点从 (0,0) 连续移到 (1,1)，所有平移操作也构成李群。
<br>定义：SO (3) 是所有 3×3 实正交矩阵且行列式为 1 的集合，即
SO(3)={R∈R3×3∣RTR=I,det(R)=1}
其中 RT 是矩阵 R 的转置，I 是 3 阶单位矩阵，det(R)=1 确保旋转无反射。<br>几何意义：SO (3) 中的每个元素 R 唯一对应三维欧氏空间 E3 中绕某条过原点的轴的旋转操作，即 “三维旋转的全体集合”。
<br>李代数定义：so (3) 是所有 3×3 实反对称矩阵（斜对称矩阵）的集合。
反对称矩阵，由向量叉乘而来，将叉乘转为线性运算的形式。
<br>李代数 so (3) 并非孤立存在，而是通过指数映射（Exponential Map） 与李群 SO (3) 建立 “局部一一对应”，通过对数映射（Logarithmic Map） 实现反向映射，这是李代数 “生成” 李群的关键机制。

    
        
 



