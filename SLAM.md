 Linux 系统的目录结构遵循（Filesystem Hierarchy Standard，文件系统层次结构标准），所有目录都从根目录开始，形成一个树状结构。这种统一的结构让不同 Linux 发行版（如 Ubuntu、CentOS、Debian 等）的目录布局保持一致，方便用户和程序定位文件。
## 核心目录及其功能
### 1. 系统基础与启动相关
- **`/`（根目录）**  
  整个文件系统的起点，所有目录和文件都挂载在根目录下。

- **`/boot`**  
  存放系统启动必需的文件，包括 Linux 内核（`vmlinuz`）、引导加载程序（如 GRUB 的配置文件 `grub.cfg`）、启动镜像等。系统启动时，BIOS/UEFI 会从这里加载内核。

- **`/sbin`**  
  存放**系统管理命令**，仅 root 用户（超级管理员）常用，用于系统维护，如 `reboot`（重启）、`fdisk`（磁盘分区）、`ifconfig`（网络配置，部分发行版已被 `ip` 替代）等。
### 2. 系统配置与核心文件
- **`/etc`**  
  存放**系统和应用程序的配置文件**，是 Linux 中最常用的目录之一。例如：  
  - 网络配置：`/etc/network/interfaces`（网络接口配置）、`/etc/resolv.conf`（DNS 服务器）；  
  - 用户配置：`/etc/passwd`（用户账户信息）、`/etc/group`（用户组信息）；  
  - 服务配置：`/etc/systemd/system`（systemd 服务配置）、`/etc/nginx`（Nginx 服务器配置）。

- **`/lib` 与 `/lib64`**  
  存放系统运行必需的**共享库文件**（类似 Windows 的 DLL 文件）和内核模块（`.ko`）。  
  - `lib` 对应 32 位系统或 64 位系统的兼容库；  
  - `lib64` 仅在 64 位系统中存在，存放 64 位库文件。
### 3. 设备与虚拟文件系统
- **`/dev`**  
  存放**设备文件**（Linux 中“一切皆文件”，硬件设备通过文件抽象）。例如：  
  - 硬盘：`/dev/sda`（第一块 SATA 硬盘）、`/dev/nvme0n1`（第一块 NVMe 硬盘）；  
  - 终端：`/dev/tty1`（第一个虚拟终端）；  
  - 光驱：`/dev/cdrom`。

- **`/proc`**  
  虚拟文件系统（不占用磁盘空间，数据存于内存），反映**系统实时状态**。例如：  
  - 进程信息：`/proc/1234`（PID 为 1234 的进程详情）；  
  - 系统资源：`/proc/meminfo`（内存使用情况）、`/proc/cpuinfo`（CPU 信息）。

- **`/sys`**  
  虚拟文件系统，主要用于**硬件设备的配置与状态查询**，比 `/proc` 更侧重硬件细节。例如：`/sys/class/net`（网络接口信息）、`/sys/devices`（设备树）。


### 4. 用户与应用相关
- **`/home`**  
  普通用户的**家目录**，每个用户在这里有独立的子目录（如 `/home/zhang`、`/home/lisi`），用于存放用户的个人文件（文档、下载、配置等）。
- **`/root`**  
  超级管理员（root 用户）的家目录，与普通用户的 `/home` 分开，权限更高。
- **`/bin`**  
  存放**基础用户命令**，所有用户均可访问，且系统启动时就需要这些命令（如 `ls` 列表、`cp` 复制、`mkdir` 创建目录等）。
- **`/usr`**  
  存放“用户可共享的程序和数据”，是系统中最大的目录之一，内部结构类似根目录：  
  - `usr/bin`：非启动必需的用户命令（如 `gcc` 编译器、`python` 解释器）；  
  - `usr/sbin`：非启动必需的系统命令（如 `apache2` 服务器启动命令）；  
  - `usr/lib`：应用程序的库文件；  
  - `usr/share`：共享数据（如文档、图标、字体等）；  
  - `usr/local`：用户手动安装的软件（如源码编译的程序，避免与系统自带软件冲突）。
- **`/opt`**  
  存放**第三方可选应用**（通常是大型软件），如 Oracle 数据库、Matlab 等，方便集中管理和卸载。

### 5. 临时与可变数据
- **`/tmp`**  
  临时文件目录，所有用户可读写，系统会定期自动清理（或重启后清空），适合存放临时缓存、日志等。

- **`/var`**  
  存放**“可变数据”**（内容随系统运行动态变化）：  
  - `var/log`：系统和应用程序的日志文件（如 `syslog` 系统日志、`auth.log` 登录日志）；  
  - `var/cache`：应用程序的缓存（如浏览器缓存、软件包缓存）；  
  - `var/mail`：用户邮件；  
  - `var/spool`：队列数据（如打印任务、定时任务）。


### 6. 外部存储挂载
- **`/mnt`**  
  手动挂载外部存储设备（如 U 盘、移动硬盘、网络共享目录）的临时挂载点，例如 `mount /dev/sdb1 /mnt/usb` 可将 U 盘挂载到 `/mnt/usb`。

 - **`/media`**  
  自动挂载外部设备的目录（现代 Linux 发行版常用），插入 U 盘或光盘时，系统会自动在 `/media/用户名/设备名` 下创建挂载点。


## 总结
Linux 目录结构的设计遵循“功能分离”原则：系统文件与用户文件分离、静态文件（如程序）与动态文件（如日志）分离、必需文件与可选文件分离。理解这些目录的作用，能帮助你快速定位文件、排查问题（如日志在 `/var/log`，配置在 `/etc`），是使用 Linux 的基础。
## linux中ubuntu安装软件操作
### 通过APT安装包安装
- sudo apt update
- sudo apt install firefox
- sudo apt remove firefox
- sudo apt upgrade  # 升级所有可更新的软件
- sudo apt upgrade firefox  # 仅升级指定软件
- apt search [关键词]  # 例如查找 "编辑器" 相关软件：apt search editor
### 源码编译安装
安装编译工具（首次编译需执行）：
- bash
- sudo apt install build-essential  # 包含 gcc、make 等基础编译工具
下载并解压源码包：
例如下载 example-1.0.tar.gz 后，在终端解压：
- bash
- tar -zxvf example-1.0.tar.gz  # 解压 gz 格式
- cd example-1.0  # 进入解压后的目录
配置编译参数：
大多数源码包会提供 configure 脚本，用于检查依赖并生成 Makefile：
- bash
./configure  # 可添加参数，如指定安装路径：./configure --prefix=/usr/local
编译源码：
- bash
- make  # 编译过程可能耗时，取决于软件复杂度
安装编译好的软件：
- bash
- sudo make install
卸载源码安装的软件（需在源码目录执行）：
- bash
- sudo make uninstall


# 视觉SLAM
## 定位和建图
### 传感器
- 机器人：轮式编码器、相机、激光、imu
- 环境：导轨、二维码标志
### 相机
 拍摄的图像需要恢复三维结构，恢复相机的运动和远近大小。
 单目相机通过视差可以定量的判断远近，但是存在尺度不确定性。
 双目相机可以获得尺度信息，但是计算量大。深度相机适合室内。
### SLAM框架
![](https://github.com/aurara-i/markdown/blob/main/picture/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-04%20185108.png)
- 前端视觉里程计：估算相邻图像之间相机运动。每次估计会存在偏差，因此会存在累积飘移，因此需要进行后端优化和回环检测。（计算机领域）
- 后端优化：接受相机位姿和回环检测进行优化。主要就是处理噪声问题。（滤波与非线性优化）
- 回环检测：判断机器人是否到达过先前的位置，如果检测到回环提供给后端。解决为位置随时间飘移问题。
### 数学表达
- 运动：轨迹由离散的时间k和离散时间的位置xk构成。用运动方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/3.png)
  u为观测量，w为噪声。
- 观测：观测在k时刻处于xk位置观测到地图上路标yk。用观测方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/4.png)  
  v为噪声。
上述通过两个方程，通过运动观测u和传感器读数Z解决定位问题（x）和建图(y)问题。 建模为状态估计问题：线性/非线性，高斯/非高斯。
其中线性高斯系统的无偏最优估计可以由卡尔曼滤波获得。（预测与更新）我觉得上面的运动就是状态矩阵，观测就是更新矩阵。
而目前主要使用图优化进行状态估计。
### Kalman Filter（https://blog.csdn.net/qq_37214693/article/details/130927283?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&utm_relevant_index=2）
- 卡尔曼滤波的原理是赋予权重，判断哪个信息的可信度高，可信度高的就赋予更高的权重，可信度低的赋予权重低，由此获得最优估计。
- 基于状态信息的运动方程获得先验状态矩阵，传感器量测到的状态值获得状态观测矩阵。两者结合处理后获得后验状态矩阵。最优估计为其中心。
- 1、状态方程 xₖ = Fₖxₖ₋₁ + Bₖuₖ + wₖ
- xₖ	时刻 k 的 “状态向量”	，Fₖxₖ₋₁	前一时刻状态对当前的影响	，Bₖuₖ	输入信号对当前状态的影响	，wₖ	过程噪声（随机变量）	，cov{wₖ}=Qₖ	噪声的协方差矩阵
- 2、观测方程 zₖ = Hₖxₖ + vₖ
-zₖ	时刻 k 的 “观测向量”	，Hₖxₖ	状态对观测的 “理想映射”	，vₖ	观测噪声（随机变量），cov{vₖ}=Rₖ	观测噪声的协方差矩阵	
#### 是先通过状态方程 “预测” 当前状态，再用观测方程的实际测量结果 “校正” 这个预测值，最终得到更接近真实状态的估计值。如果发现预测的状态偏了就进行修正。若观测噪声 vₖ小（GPS 精度高，Rₖ小），就 “多信观测”，让修正后的状态更靠近 zₖ；若过程噪声 wₖ小（状态预测准，Qₖ小），就 “多信预测”，少修正一点。
- 3、状态估计误差  \(\tilde{x}_{k|k - 1} = x_k - \hat{x}_{k|k - 1}\) 
- x_k：k 时刻系统的真实状态。这是客观存在的物理量，但无法直接获取（只能通过估计逼近）。
- \(\hat{x}_{k|k-1}\)：k-1 时刻对 k 时刻状态的预测估计值
- \(\tilde{x}_{k|k-1}\)：k 时刻的预测误差（也称 “先验误差”），即 “真实状态与预测估计值的偏差”。
- 4、状态估计方程 \(\hat{x}_{k|k-1} = F_k \hat{x}_{k-1} + B_k u_k\)
- 利用 k-1 时刻的最优状态估计和 k 时刻的控制输入，预测 k 时刻的状态
- 5、观测估计误差 e~k=z k − z^k∣k−1
- 6、观测估计方程z^k∣k−1=H kx^k∣k−1
####  这里的估计，不包含随机且不确定的误差。卡尔曼滤波通过 “先做无噪声的理想预测，后续再用噪声的统计特性（协方差）修正” 的两步法，间接处理了噪声的影响，既保证了估计的 “基础逻辑简洁性”，又能通过统计方法实现 “最优修正”。
- 7、状态误差协方差矩阵 P k∣k−1​=cov{ x~k∣k−1}
- 8、观测误差协方差矩阵 S K=cov{ e~k}
- 9、 迭代估计表达式  \(\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k \tilde{e}_k\)
​这里的K就是卡尔曼增益。因此，我们需要推导出所用变量的迭代式，并求得卡尔曼增益。


