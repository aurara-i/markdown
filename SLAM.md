
 Linux 系统的目录结构遵循（Filesystem Hierarchy Standard，文件系统层次结构标准），所有目录都从根目录开始，形成一个树状结构。这种统一的结构让不同 Linux 发行版（如 Ubuntu、CentOS、Debian 等）的目录布局保持一致，方便用户和程序定位文件。
## 核心目录及其功能
### 1. 系统基础与启动相关
- **`/`（根目录）**  
  整个文件系统的起点，所有目录和文件都挂载在根目录下。

- **`/boot`**  
  存放系统启动必需的文件，包括 Linux 内核（`vmlinuz`）、引导加载程序（如 GRUB 的配置文件 `grub.cfg`）、启动镜像等。系统启动时，BIOS/UEFI 会从这里加载内核。

- **`/sbin`**  
  存放**系统管理命令**，仅 root 用户（超级管理员）常用，用于系统维护，如 `reboot`（重启）、`fdisk`（磁盘分区）、`ifconfig`（网络配置，部分发行版已被 `ip` 替代）等。
### 2. 系统配置与核心文件
- **`/etc`**  
  存放**系统和应用程序的配置文件**，是 Linux 中最常用的目录之一。例如：  
  - 网络配置：`/etc/network/interfaces`（网络接口配置）、`/etc/resolv.conf`（DNS 服务器）；  
  - 用户配置：`/etc/passwd`（用户账户信息）、`/etc/group`（用户组信息）；  
  - 服务配置：`/etc/systemd/system`（systemd 服务配置）、`/etc/nginx`（Nginx 服务器配置）。

- **`/lib` 与 `/lib64`**  
  存放系统运行必需的**共享库文件**（类似 Windows 的 DLL 文件）和内核模块（`.ko`）。  
  - `lib` 对应 32 位系统或 64 位系统的兼容库；  
  - `lib64` 仅在 64 位系统中存在，存放 64 位库文件。
### 3. 设备与虚拟文件系统
- **`/dev`**  
  存放**设备文件**（Linux 中“一切皆文件”，硬件设备通过文件抽象）。例如：  
  - 硬盘：`/dev/sda`（第一块 SATA 硬盘）、`/dev/nvme0n1`（第一块 NVMe 硬盘）；  
  - 终端：`/dev/tty1`（第一个虚拟终端）；  
  - 光驱：`/dev/cdrom`。

- **`/proc`**  
  虚拟文件系统（不占用磁盘空间，数据存于内存），反映**系统实时状态**。例如：  
  - 进程信息：`/proc/1234`（PID 为 1234 的进程详情）；  
  - 系统资源：`/proc/meminfo`（内存使用情况）、`/proc/cpuinfo`（CPU 信息）。

- **`/sys`**  
  虚拟文件系统，主要用于**硬件设备的配置与状态查询**，比 `/proc` 更侧重硬件细节。例如：`/sys/class/net`（网络接口信息）、`/sys/devices`（设备树）。


### 4. 用户与应用相关
- **`/home`**  
  普通用户的**家目录**，每个用户在这里有独立的子目录（如 `/home/zhang`、`/home/lisi`），用于存放用户的个人文件（文档、下载、配置等）。
- **`/root`**  
  超级管理员（root 用户）的家目录，与普通用户的 `/home` 分开，权限更高。
- **`/bin`**  
  存放**基础用户命令**，所有用户均可访问，且系统启动时就需要这些命令（如 `ls` 列表、`cp` 复制、`mkdir` 创建目录等）。
- **`/usr`**  
  存放“用户可共享的程序和数据”，是系统中最大的目录之一，内部结构类似根目录：  
  - `usr/bin`：非启动必需的用户命令（如 `gcc` 编译器、`python` 解释器）；  
  - `usr/sbin`：非启动必需的系统命令（如 `apache2` 服务器启动命令）；  
  - `usr/lib`：应用程序的库文件；  
  - `usr/share`：共享数据（如文档、图标、字体等）；  
  - `usr/local`：用户手动安装的软件（如源码编译的程序，避免与系统自带软件冲突）。
- **`/opt`**  
  存放**第三方可选应用**（通常是大型软件），如 Oracle 数据库、Matlab 等，方便集中管理和卸载。

### 5. 临时与可变数据
- **`/tmp`**  
  临时文件目录，所有用户可读写，系统会定期自动清理（或重启后清空），适合存放临时缓存、日志等。

- **`/var`**  
  存放**“可变数据”**（内容随系统运行动态变化）：  
  - `var/log`：系统和应用程序的日志文件（如 `syslog` 系统日志、`auth.log` 登录日志）；  
  - `var/cache`：应用程序的缓存（如浏览器缓存、软件包缓存）；  
  - `var/mail`：用户邮件；  
  - `var/spool`：队列数据（如打印任务、定时任务）。


### 6. 外部存储挂载
- **`/mnt`**  
  手动挂载外部存储设备（如 U 盘、移动硬盘、网络共享目录）的临时挂载点，例如 `mount /dev/sdb1 /mnt/usb` 可将 U 盘挂载到 `/mnt/usb`。

 - **`/media`**  
  自动挂载外部设备的目录（现代 Linux 发行版常用），插入 U 盘或光盘时，系统会自动在 `/media/用户名/设备名` 下创建挂载点。


## 总结
Linux 目录结构的设计遵循“功能分离”原则：系统文件与用户文件分离、静态文件（如程序）与动态文件（如日志）分离、必需文件与可选文件分离。理解这些目录的作用，能帮助你快速定位文件、排查问题（如日志在 `/var/log`，配置在 `/etc`），是使用 Linux 的基础。
## linux中ubuntu安装软件操作
### 通过APT安装包安装
- sudo apt update
- sudo apt install firefox
- sudo apt remove firefox
- sudo apt upgrade  # 升级所有可更新的软件
- sudo apt upgrade firefox  # 仅升级指定软件
- apt search [关键词]  # 例如查找 "编辑器" 相关软件：apt search editor
### 源码编译安装
安装编译工具（首次编译需执行）：
- bash
- sudo apt install build-essential  # 包含 gcc、make 等基础编译工具
下载并解压源码包：
例如下载 example-1.0.tar.gz 后，在终端解压：
- bash
- tar -zxvf example-1.0.tar.gz  # 解压 gz 格式
- cd example-1.0  # 进入解压后的目录
配置编译参数：
大多数源码包会提供 configure 脚本，用于检查依赖并生成 Makefile：
- bash
./configure  # 可添加参数，如指定安装路径：./configure --prefix=/usr/local
编译源码：
- bash
- make  # 编译过程可能耗时，取决于软件复杂度
安装编译好的软件：
- bash
- sudo make install
卸载源码安装的软件（需在源码目录执行）：
- bash
- sudo make uninstall


# 视觉SLAM 
## 定位和建图
### 传感器
- 机器人：轮式编码器、相机、激光、imu
- 环境：导轨、二维码标志
### 相机
 拍摄的图像需要恢复三维结构，恢复相机的运动和远近大小。
 单目相机通过视差可以定量的判断远近，但是存在尺度不确定性。
 双目相机可以获得尺度信息，但是计算量大。深度相机适合室内。
### SLAM框架
![](https://github.com/aurara-i/markdown/blob/main/picture/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202025-09-04%20185108.png)
- 前端视觉里程计：估算相邻图像之间相机运动。每次估计会存在偏差，因此会存在累积飘移，因此需要进行后端优化和回环检测。（计算机领域）
- 后端优化：接受相机位姿和回环检测进行优化。主要就是处理噪声问题。（滤波与非线性优化）
- 回环检测：判断机器人是否到达过先前的位置，如果检测到回环提供给后端。解决为位置随时间飘移问题。
### 数学表达
- 运动：轨迹由离散的时间k和离散时间的位置xk构成。用运动方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/3.png)
  u为观测量，w为噪声。
- 观测：观测在k时刻处于xk位置观测到地图上路标yk。用观测方程表示：
![](https://github.com/aurara-i/markdown/blob/main/picture/4.png)  
  v为噪声。
上述通过两个方程，通过运动观测u和传感器读数Z解决定位问题（x）和建图(y)问题。 建模为状态估计问题：线性/非线性，高斯/非高斯。
其中线性高斯系统的无偏最优估计可以由卡尔曼滤波获得。（预测与更新）我觉得上面的运动就是状态矩阵，观测就是更新矩阵。
而目前主要使用图优化进行状态估计。
### Kalman Filter（https://blog.csdn.net/qq_37214693/article/details/130927283?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7ECtr-1-130927283-blog-142596142.235%5Ev43%5Econtrol&utm_relevant_index=2）
  - 卡尔曼滤波的原理是赋予权重，判断哪个信息的可信度高，可信度高的就赋予更高的权重，可信度低的赋予权重低，由此获得最优估计。
  - 基于状态信息的运动方程获得先验状态矩阵，传感器量测到的状态值获得状态观测矩阵。两者结合处理后获得后验状态矩阵。最优估计为其中心。
- 1、状态方程 xₖ = Fₖxₖ₋₁ + Bₖuₖ + wₖ
  - xₖ	时刻 k 的 “状态向量”	，Fₖxₖ₋₁	前一时刻状态对当前的影响	，Bₖuₖ	输入信号对当前状态的影响	，wₖ	过程噪声（随机变量）	，cov{wₖ}=Qₖ	噪声的协方差矩阵
- 2、观测方程 zₖ = Hₖxₖ + vₖ
  -zₖ	时刻 k 的 “观测向量”	，Hₖxₖ	状态对观测的 “理想映射”	，vₖ	观测噪声（随机变量），cov{vₖ}=Rₖ	观测噪声的协方差矩阵	
#### 是先通过状态方程 “预测” 当前状态，再用观测方程的实际测量结果 “校正” 这个预测值，最终得到更接近真实状态的估计值。如果发现预测的状态偏了就进行修正。若观测噪声 vₖ小（GPS 精度高，Rₖ小），就 “多信观测”，让修正后的状态更靠近 zₖ；若过程噪声 wₖ小（状态预测准，Qₖ小），就 “多信预测”，少修正一点。
![](https://github.com/aurara-i/markdown/blob/main/picture/5.png)
- 3、状态估计误差 \(\tilde{x}_{k|k - 1} = x_k - \hat{x}_{k|k - 1}\) 
  - x_k：k 时刻系统的真实状态。这是客观存在的物理量，但无法直接获取（只能通过估计逼近）。
  - k-1 时刻对 k 时刻状态的预测估计值
  -k 时刻的预测误差（也称 “先验误差”），即 “真实状态与预测估计值的偏差”。
- 4、状态估计方程 
  - 利用 k-1 时刻的最优状态估计和 k 时刻的控制输入，预测 k 时刻的状态
- 5、观测估计误差 
- 6、观测估计方程
####  这里的估计，不包含随机且不确定的误差。卡尔曼滤波通过 “先做无噪声的理想预测，后续再用噪声的统计特性（协方差）修正” 的两步法，间接处理了噪声的影响，既保证了估计的 “基础逻辑简洁性”，又能通过统计方法实现 “最优修正”。
- 7、状态误差协方差矩阵 
- ![](https://github.com/aurara-i/markdown/blob/main/picture/6.png)
- 8、观测误差协方差矩阵
- 9、 迭代估计表达式  \(\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k \tilde{e}_k\) 
 #### 这里的K就是卡尔曼增益。因此，我们需要推导出所用变量的迭代式，并求得卡尔曼增益。这是核心权重。如果 “猜测的观测” 很不准，或 “观测噪声” 很准，增益  就大（更信观测）；反之则小（更信猜测）。
-后验估计
-  ![](https://github.com/aurara-i/markdown/blob/main/picture/7.png)
 ####  状态估计误差：下标 (k|k-1) 的含义是k 时刻的状态，基于k-1 时刻的信息进行估计”。因为 k-1 时刻时，k 时刻还未到来，只能预测未来（用过去的信息猜未来的状态），所以用 “(k|k-1)” 明确 “估计的时间逻辑”——“基于过去，估计未来”。而观测估计误差下标 k 的含义是 “k 时刻的观测”。因为观测 (z_k) 是k 时刻实时获取的测量值（比如 GPS 在 k 时刻的读数），误差直接对应 “当前时刻（k）的观测”，所以用简洁的 k 表示 “这是 k 时刻的观测相关误差”。
![](https://github.com/aurara-i/markdown/blob/main/picture/8.png)
## G++编译器
- `g++ helloslam.cpp`生成./a.out的可执行文件，在终端中输入这个可执行文件就可以成功运行。
## CMAKE基础
 - 这确实是我第一次真正生成Cmake。值的记录！！
  - 新建并在CMakeLists.txt中写
  - **` cmake_minimum_required(VERSION 3.10)#声明的要求最低版本CMake `**
  - **` project(Untitled-1)#声明工程 `**
  - **` add_executable(Untitled-1 Untitled-1.cpp)#添加可执行程序（程序名 源代码文件）`**
   - 然后在终端输入cmake . 就会生成一些中间文件。
   - 再输入make进行编译
 - 编译成功后输入：./Untitled-1 可执行程序就能够执行了,输出helllo slam!
 - 所以如果想要新增一个可执行文件，只需要再添加一行就行。
 - 我们希望生成的中间文件不要放在代码目录中，新建一个build目录然后进行Cmake和make
 -  **如何生成库**
 - 我们自己生成库，在cmakelist.txt中增加：add_library( .cpp),然后和上面一样cmake编译就行。生成的.a文件就是想要的库。
 - 还需要一个头文件才能够调用库。头文件包括宏定义和函数名
 - 然后在cmakelist中增加可执行程序的生成命令连接到库上，target_link_libraries()
## 三维刚体运动 
 - **内积**  内积是描述向量之间的投影关系。
 - **外积**  外积的结果是一个向量，方向垂直于这两个向量，是两个向量张成的四边形的有向面积。向量叉乘 a×b 的结果可以通过将向量 a 转化为反对称矩阵 a∧ 后与向量 b 做矩阵乘法。

 - 如图，把外积写成了矩阵与向量的乘法，变成了线性运算。任意向量都唯一对应一个反对称矩阵。
- **刚体运动** 运动过程中向量大小不会发生变化。
- **欧式变换** 导航坐标系和世界坐标系之间差了一个欧式变换，欧式变换由旋转和平移构成。
- **旋转矩阵（方向余弦矩阵）** R12 表示把坐标系2的向量变换到1中。求逆表示反向的旋转。

- 如图，旋转矩阵来源。
- 对于**旋转矩阵的实践**，我们主要使用EIGEIN库进行矩阵的计算。这个库是由纯头文件构成，无需连接库文件，只需引入头文件即可。
- **Eigien库矩阵的使用**
- 所以在CMakeLists.txt中 include_directories( "/usr/include/eigen3" )
    -- **可以省略的情况：**
    Eigen 是纯头文件库，若其安装路径在系统默认的头文件搜索路径中（如 Linux 的/usr/include、/usr/local/include，或通过包管理器安装时自动配置的路径），CMake 会自动找到它，无需手动指定。
    -- **必须保留的情况：**
    若 Eigen 安装在非默认路径（如自定义目录、Windows 系统中手动解压的路径），则必须通过这行指定头文件位置，否则编译时会提示 “找不到 Eigen 头文件”。
- `Eigein::Matrix<double ,3 ,3> Matrix3d;`//三维矩阵原始定义
- `Eigein::Matrix3d matrix3d=Eigein::Matrix3d::Zero()`//内置的三维矩阵直接调用，可初始化为0
- `Eigein::Matrix<double,Eigein::Dynamic,Eigein::Dynamic> Matrixnd`//矩阵大小动态设置
- `matrix3d=1,2,3,4,5,6,7,8,9;`//三维矩阵初始化
- `cout<<matrix3d;`//进行输出
- `for（int i=0；i<3;i++） for(int j=0;j<3;j++) cout<<matrix3d(i,j)`//访问特定元素
- `.transpose 转置 .trace 迹 .inverse 逆 .determinant行列式`
- `Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> eigen_solver ( matrix_33.transpose()*matrix_33 );`//使用 Eigen 库中的SelfAdjointEigenSolver类来求解一个 3x3 矩阵的特征值和特征向量
    - matrix_33.transpose() * matrix_33
    对原始矩阵matrix_33做转置（.transpose()）后，再与自身相乘。
    数学意义：这样得到的新矩阵一定是对称矩阵（满足A^T = A），且是半正定的（特征值非负）。
    - Eigen::SelfAdjointEigenSolver<...>
    这是 Eigen 中专门用于求解对称矩阵特征值和特征向量的工具类（SelfAdjoint表示 “自伴随”，即对称矩阵）。
    - `eigen_solver`
    是实例化的求解器对象，通过它可以获取计算出的特征值和特征向量。
 - 解方程
    - 直接求逆
    - 史密特正交化`x = matrix_NN.colPivHouseholderQr().solve(v_Nd);`
 -**旋转向量与欧拉角**
 - 旋转向量：任何旋转都可以由一个旋转轴和旋转角刻画，我们用一个向量方向和旋转轴一致，长度等于旋转角对旋转刻画。
 - 三维空间中的刚体运动共有六个自由度：三个旋转自由度 + 三个平移自由度；旋转向量可把旋转压缩为三维，平移向量本身是三维，两者拼起来正好六维，能无冗余且完备地描述刚体变换。而上面的旋转矩阵用十六个量表示了六个自由度的变换。 从旋转向量到旋转矩阵的转换过程为**罗德里格斯公式**。
 - 旋转矩阵R是 3×3 矩阵（9 个元素），但它必须满足 **“正交性” 和 “右手坐标系”** 两个核心约束，这会消除 6 个自由度，最终只剩 3 个独立参数。
 - 对于 3×3 矩阵，RTR=I意味着：
    - 每行（或列）都是单位向量（3 个方程）：比如第一行满足r112​+r122​+r132​=1；
    - 不同行（或列）互相垂直（3 个方程）：比如第一行和第二行满足r11​r21​+r12​r22​+r13​r23​=0。
    - 共 6 个方程，每个方程都会减少一个自由度，因此 9 - 6 = 3。
 - 旋转轴是三维空间中的一个单位向量n=(nx​,ny​,nz​)，但 “单位向量” 的约束会减少一个自由度，因此从 3 个参数变成 2 个独立参数。旋转角为一个自由度。
 - **欧拉角**
 - 把旋转等价于三个分离的转角，三次绕不同轴的转动。俯仰、横滚、偏航。存在万向锁的问题，奇异性。同理，上面的旋转向量在180度的时候也会存在奇异性。
 - **四元数**
 - 没有奇异性。q=q0+q1i+q2j+q3k
    -q0​ 是实部，q1​,q2​,q3​ 是虚部（对应三维空间的 3 个维度）；i,j,k 是四元数的虚数单位，满足特殊的乘法规则：i2=j2=k2=−1，ij=k,jk=i,ki=j（右手定则），且乘法不满足交换律（如 ji=−k）。
 - 表示旋转：
   - 旋转四元数的关键约束：**单位四元数**。并非所有四元数都能表示旋转 ——只有 “单位四元数”（模长为 1 的四元数）才能描述旋转。这一约束的本质是：旋转不改变向量的长度，单位四元数的乘法能保证 “长度不变性”（类似旋转矩阵的正交性）。
   - 三维空间的任意旋转，都可唯一分解为 “绕某一固定轴旋转特定角度”（欧拉旋转定理）。四元数正是直接对应这一分解：
   - 若旋转的单位轴向量为 u=[ux​,uy​,uz​]T（∥u∥=1），旋转角为 θ（右手定则：拇指沿 u 正向，四指弯曲方向为旋转方向），则对应的单位四元数为：
   - q=cos(2|θ​)+ux​sin(2|θ​)i+uy​sin(2|θ​)j+uz​sin(2θ​)k
   - 可简化为 “实部 + 虚部向量” 的形式：
   - q=[cos(2θ​),ux​sin(2θ​),uy​sin(2θ​),uz​sin(2θ​)]T
实部表示旋转角度，虚部表示旋转方向。
 -  θ/2 编码能完美匹配现实中的旋转效果 —— 这是因为 θ/2 编码恰好抵消了 “四元数乘法的双线性特性”（数学上，四元数旋转对应 “SU (2) 群”，而 3D 旋转对应 “SO (3) 群”，θ/2 是这两个群同态映射的关键）。
 - **几种旋转之间转换**
 - **旋转变化明天再看把，困死了**
 - 相似变换：旋转、平移、缩放
 - 仿射变换：旋转矩阵不要求正交
 - **Eigein库中旋转的使用**
   - 在 Eigen 中，**AngleAngleAxis** 是一种专门用于表示旋转向量的类，它的底层实现不是矩阵，而是直接存储了 “旋转角度” 和 “旋转轴方向” 这两个核心信息。
   - ` Eigen::AngleAxisd rotation_vector ( M_PI/4, Eigen::Vector3d ( 0,0,1 ) );`
   -  **旋转向量 转 旋转矩阵**
   - `cout<<"rotation matrix =\n"<<rotation_vector.matrix() <<endl;` //直接转为矩阵
   - 也可以`rotation_matrix = rotation_vector.toRotationMatrix();`//或者用这个函数
   - **旋转矩阵 转 欧拉角**
   - `Eigen::Vector3d euler_angles = rotation_matrix.eulerAngles ( 2,1,0 ); // ZYX顺序，即roll pitch yaw顺序`
   - **用旋转向量和旋转矩阵进行坐标变换**
   -  `::Vector3d v ( 1,0,0 );`
   -  `Eigen::Vector3d v_rotated = rotation_vector * v;`
   -  `v_rotated = rotation_matrix * v;`
   -  **欧式变换矩阵**
   -  `Eigen::Isometry3d T = Eigen::Isometry3d::Identity();`
   -  `Isometry3d 是 Eigen 中专门用于表示三维欧氏变换的类（“Isometry” 意为 “等距变换”，即保距变换）。虽然名字带 “3d”，但内部存储的是 4×4 矩阵（因为需要包含平移部分）。`
   -  `T.rotate(rotation_vector);  // 应用之前定义的旋转向量，当然，这里换成其他旋转的表达也是ok的`
   -  `T.pretranslate(Eigen::Vector3d(1,3,4));  // 平移向量 t = (1,3,4)`
   -  也可以直接`Eigen::Vector3d v_transformed = T * v;  // v 是初始向量 (1,0,0)`
   -  这里的 * 运算符是 Eigen 重载的欧氏变换操作，等价于数学上的：vtransformed​=R⋅v+t
即 “先对向量 v 应用旋转 R，再加上平移 t”。
   -  **四元数**
   - `Eigen::Quaterniond q = Eigen::Quaterniond(rotation_vector);`
   - `q = Eigen::Quaterniond(rotation_matrix);`
   - `v_rotated = q * v;  // 数学上等价于 q·v·q⁻¹`//用四元数旋转一个矩阵
  - **可视化演示**
  - **小萝卜的例子**
  - 1、四元数先转的在右侧，我给忘记了。
  - 2、四元数一定要定义完成后归一化。
  - 3、**这里的位姿原来指的是再载体坐标系下的，所以对于旋转向量直接q1q2之间求就可以了。对于位置平移向量，要先把t1转回世界坐标系再转到2。**
<br>**李群李代数 抽象的一**<br>  （讲的很好：https://juejin.cn/post/7499014256548200474   https://juejin.cn/post/7502610991740026906）
<br>群：一种集合加一种运算。具有封闭性、结合律、幺元、逆的性质。<br>
<br> 李群：具有连续性质的群。对乘法是封闭的但是对加法不是封闭的。李群是具有光滑性质的群，它意味着这个函数的每个点都可以用切线方程来近似，从而使得复杂的问题可以通过简单的线性问题来解决，极大地简化了计算。两个重要的李群是特殊正交群SO(n)SO(n) 和 特殊欧式群SE(n)SE(n)，特殊正交群是旋转变换的集合和运算，特殊欧式群是欧式变换/刚性变换的集合和运算。<br>
<br>旋转群 SO (3)：三维空间中绕任意轴的旋转（比如地球自转、方向盘转动）。这些旋转操作满足 “群的 4 条规则”（封闭性：两个旋转叠加还是旋转；结合律：旋转顺序不影响最终结果；单位元：不旋转的 “零操作”；逆元：转 30° 再转 - 30° 回到原位），且旋转角度可以连续从 0° 变到 360°，是典型的李群。<br>
<br>平移群：在平面上把一个点从 (0,0) 连续移到 (1,1)，所有平移操作也构成李群。<br>
<br>定义：SO (3) 是所有 3×3 实正交矩阵且行列式为 1 的集合，即
SO(3)={R∈R3×3∣RTR=I,det(R)=1}
其中 RT 是矩阵 R 的转置，I 是 3 阶单位矩阵，det(R)=1 确保旋转无反射。<br>几何意义：SO (3) 中的每个元素 R 唯一对应三维欧氏空间 E3 中绕某条过原点的轴的旋转操作，即 “三维旋转的全体集合”。<br>
<br>李代数的引入，对旋转矩阵求☯，等于一个反对称矩阵乘以这个旋转矩阵 ，也就是说每对旋转矩阵求一次☯就左乘一个反对称矩阵。这样构成了一个一阶微分方程，求出的结果就是旋转矩阵和反对称矩阵之间的指数关系。这个反对称矩阵就是旋转矩阵对应的李代数。 <br>
<br>李代数定义：李代数是由两部分组成的 “数学对象”，记为 (g,[⋅,⋅])，其中：
    <br>g（读作 “g frak”）：一个线性空间（可以简单理解为 “一堆能做‘加法’和‘数乘’的元素”，比如三维空间里的向量、矩阵集合等）；
    <br>[⋅,⋅]（读作 “李括号”）：定义在 g 上的二元运算（即 “拿两个元素，通过这个运算得到第三个元素，且结果仍在 g 里”）。李代数的所有性质，都是对这个 “李括号” 的规则约束。
    <br>性质 1：双线性（Bilinearity）—— 运算对 “加法” 和 “数乘” 友好.保证李代数能和 “线性空间” 的结构结合 —— 线性空间本身有加法和数乘，李括号的双线性让这两种结构不冲突，不会出现 “算完李括号就超出线性空间” 的情况。[ax+by,z]=a[x,z]+b[y,z]
   <br>性质 2：反交换性（Anticommutativity）—— 交换输入，结果变号。把李括号的两个输入 “换位置”，得到的结果是原来的 “相反数”： 这是李代数区别于普通 “代数” 的关键之一。普通乘法（比如数的乘法、矩阵乘法）是 “交换的”（xy=yx），但李括号是 “反交换的”—— 它描述的往往是 “非交换的相互作用”
<br>性质 3：雅可比恒等式（Jacobi Identity）—— 三个元素的 “循环作用” 平衡
对任意三个元素 x,y,z，满足：[x,[y,z]]+[y,[z,x]]+[z,[x,y]]=0<br>
<br> ϕ​1​,ϕ​2​：是 李代数 so(3) 中两个元素,.Φ​1​=ϕ​1∧​,Φ​2​=ϕ​2∧​：是将三维向量转化为反对称矩阵的结果
<br> [ϕ​1​,ϕ​2​]=(Φ​1​Φ​2​−Φ​2​Φ​1​)∧ //我们可以把 ϕ​ 想象成 “想让物体往某个方向转的念头”，李括号 [ϕ​1​,ϕ​2​] 就是 **“两个旋转念头相互作用后，产生的新念头”**。
    矩阵乘法的非交换性（Φ​1​Φ​2​=Φ​2​Φ​1​ 一般成立），使得交换子能刻画 “先按 Φ​1​ 作用再按 Φ​2​ 作用” 与 “先按 Φ​2​ 作用再按 Φ​1​ 作用” 的差异。再通过反对称化的逆映射 ∧−1（即式中的 (⋅)∧ 在此处为逆操作，将反对称矩阵映射回三维向量），将交换子的结果投影回 R3，得到李括号 [ϕ​1​,ϕ​2​]。<br>
<br>李代数 so (3) 并非孤立存在，而是通过指数映射（Exponential Map） 与李群 SO (3) 建立 “局部一一对应”，通过对数映射（Logarithmic Map） 实现反向映射，这是李代数 “生成” 李群的关键机制。<br>
<br>反对称矩阵的指数可以进行泰勒展开，任意的一个反对称矩阵都对应着一个三维向量，可以定义这个向量的模长和单位方向向量a。由这个方向向量的性质，可以将泰勒展开的高阶项进行计算，将李代数转化为李群。最后也会获得罗德里哥斯公式，。<br>
<br>经过这个推导，我们可以知道李代数空间就是由旋转向量组成的空间。而由李代数到李群就可以利用旋转向量到旋转矩阵之间的关系获得。<br>
<br>当对一个旋转矩阵R2R_{2}R2​(李代数为ϕ2\phi_{2}ϕ2​)左乘一个微小旋转矩阵R1R_{1}R1​(李代数为ϕ1\phi_{1}ϕ1​)时，可以近似的看作，在原有李代数ϕ2\phi_{2}ϕ2​上加上一项Jl(ϕ2)−1ϕ1J_{l}(\phi_{2})^{-1}\phi_{1}Jl​(ϕ2​)−1ϕ1​。<br>
<br>**相机与图像**<br>
<br>**针孔模型** 这个比较简单，就是利用小孔成像和相似三角形原理。**像素坐标系**原点位于左上角，向右为u轴，向左为v轴，像素坐标系和成像平面之间差了一个缩放和原点平移。**相机内参** xy原点，fx fy焦距，出场后是固定的。确定内参的过程叫做标定。**相机外参**P点的相机坐标，是它的世界坐标系根据位姿转换到相机坐标系下。外参就是旋转矩阵和平移向量。世界坐标系通过旋转矩阵和平移向量转到相机坐标系下，然后通过内参，把相机坐标系下的坐标转为像素坐标系下。
  --公式图片 --
<br>**畸变模型** 我们在相机前面加了透镜，透镜形状引起的畸变称为径向畸变。分为：桶形和枕形畸变。由于相机组装中，透镜和成像平面不平行，会引起切向畸变。径向畸变系数k1 k2  k3  ,切向：p1  p2 。通过这五个畸变系数去计算发生畸变后的坐标。我们就可以获得点在像素平面上的正确位置了。**畸变公式如下图**<br>
<br>**双目相机模型** 单目相机无法获得深度信息，没有办法获得空间点的具体位置。双目相机通过同步采集左右相机的图像，计算图像之间的视差，便于估计像素的深度。原理依旧是利用相似三角形。<br>
<br>**RGB-D相机模型**主要原理：1、红外结构光：根据返回的结构光图案，计算距离。2、飞行时间原理：发送返回光束飞行时间。<br>
<br>**图像**在灰度图中每个像素位置对应着一个灰度值，一般来说图像是以二维数组的形式存储。第一个表示行，对应图像的高度，对应着Y轴，第二个表示列，对应图像宽度，对应着X轴。这里方向不要弄混。<br>
<br>**OPENCV实践**<br>
  - Opencv库的安装，在https://opencv.org/releases/网址中下载需要的版本即可，依旧利用上述cmake编译的过程进行编译即可，需要注意的是提前安装好Opencv的依赖项。还要利用sudo make install进行安装到机器上。
  - **利用opencv对图像进行处理(基础操作)**
    - #include <chrono> C++ 标准时间库（chrono），用于精确计算代码执行时间（比如后续遍历图像的耗时统计）。
    - cv::Mat image;OpenCV 中存储图像的数据结构（类似 “图像矩阵”），可理解为 “容器”，用来存放像素数据、图像尺寸、通道数等信息；image是变量名，此时还未赋值
    - image = cv::imread ( argv[1] ); //cv::imread函数读取指定路径下的图像。<br>cv::Mat imread(const String& filename, int flags = IMREAD_COLOR);

第二个参数 flags 决定如何读图：

    IMREAD_COLOR（默认，值=1）：读成三通道 BGR 8 位。

    IMREAD_GRAYSCALE（值=0）：读成单通道灰度 8 位。

    IMREAD_UNCHANGED（值=-1）：保持原始数据格式（不做任何转换）。

为什么深度图要用 -1？

    深度图一般是 16 位无符号整数（unsigned short），单位是毫米。

    如果用默认 1 或 0，OpenCV 会自动把它转成 8 位（0~255），深度信息就丢失了。
    - // 文件顺利读取, 首先输出一些基本信息:cout<<"图像宽为"<<image.cols<<",高为"<<image.rows<<",通道数为"<<image.channels()<<endl;
    - cv::imshow ( "image", image );      // 用cv::imshow显示图像
    - cv::waitKey ( 0 );                  // 暂停程序,等待一个按键输入
    - **cv拷贝机制**
    - cv::Mat的浅拷贝（重点特性）：
    <br>直接用=赋值时，image_another并不会复制image的像素数据，而是和image共享同一块内存（相当于 “起别名”）。
    此时修改image_another的像素，image的像素也会跟着变（因为内存是共享的）。<br>// 修改 image_another 会导致 image 发生变化image_another ( cv::Rect ( 0,0,100,100 ) ).setTo ( 0 ); <br>// 将左上角100*100的块置零<br>cv::Rect(x, y, width, height).setto(0)：创建一个矩形区域，参数分别是 “左上角 x 坐标、左上角 y 坐标、宽度、高度”，image_another(Rect(...))：获取image_another中矩形区域的子图像（依然是浅拷贝，共享内存）
    - cv::Mat::clone()：深拷贝函数
    <br>// 使用clone函数来拷贝数据
    <br>cv::Mat image_clone = image.clone();
    <br>深拷贝函数，会创建一个新的cv::Mat对象，并复制image的所有像素数据（内存不共享，是完全独立的副本）。
此时修改image_clone，image不会受到任何影响。
    - 遍历所有元素
      <br>循环的核心是 “逐行、逐列、逐通道” 遍历图像的所有像素，本质是通过 “指针操作” 高效访问图像在内存中的原始数据。
  - **图像转点云**
   - **读取数据**
    循环读取 5 组数据：
        用格式化路径（如./color/1.png）读取彩色图和深度图，存入容器；
        从pose.txt读取每张图对应的相机位姿（平移 + 旋转），用 Eigen 库转换为位姿变换矩阵（包含旋转和平移），存入容器。
    - **设置参数与初始化**
    配置相机内参（焦距、图像中心、深度缩放因子），用于像素坐标转 3D 坐标；
    定义带颜色的点云格式（XYZRGB），初始化点云对象。
    - **像素→点云转换（核心）**
    遍历每张图像的每个像素：
        读取深度值，跳过无效值（深度为 0）；
        用相机内参将 “像素坐标 + 深度” 转换为相机坐标系下的 3D 点；
        用相机位姿将 3D 点从相机坐标系转换到世界坐标系；
        读取彩色图对应像素的颜色（BGR），存入点云的颜色字段，再将点添加到点云。
    - **保存点云**
    标记点云属性（非稠密），输出点的总数，最后将点云保存为map.pcd文件。
   - **非线性优化**
     - **状态估计问题**
     - 所以我们第二章说的SLAM模型包括一个运动方程和一个观测方程，运动方程就是运动位姿SE，观测方程就是相机针孔模型。
     - 滤波器：在机器人运动过程中，融合 “机器人的运动信息”（如里程计、IMU 数据）和 “环境的观测信息”（如激光、视觉数据），处理传感器噪声和模型误差，实时估计出机器人的当前位姿（定位）和环境的地图（建图）。只关心当前时刻的状态估计，如：卡尔曼滤波器
     - 批量：而 “批量处理” 的核心就是把 “所有相关观测的误差” 加起来，找一个能让总误差最小的位姿和地图。可以在更大的范围内实现优化，如：BA优化算法。
     - 例子：比如第 3 帧的位姿因为 IMU 漂移有小误差，导致第 3 帧观测的路标点坐标也偏了；
    <br>递归处理（如 EKF）：第 4 帧只会基于第 3 帧的错误位姿继续更新，误差会越积越大；
    <br>批量处理（BA）：优化时会发现 “第 3 帧的位姿偏差导致后续多帧的误差都变大”，于是会回溯修正第 3 帧的位姿，同时调整所有相关路标点的坐标，让整体误差最小。
    - P(x,y∣z,u)=P(z,u)P(z,u∣x,y)⋅P(x,y)​∝P(z,u∣x,y)⋅P(x,y)
<br>x,y	状态：x 是机器人的位姿序列，y 是路标点坐标	
<br>z,u	数据：z 是观测（如图像），u 是输入（如 IMU）	
<br>P(x,y∣z,u)	后验概率：已知观测 z 和输入 u 时，状态 x,y 的概率	
<br>P(z,u∣x,y)	似然（Likelihood）：已知状态 x,y 时，观测 z 和输入 u
<br>P(x,y)	先验概率（Prior）：没有观测和输入时，状态 x,y 的概率	
<br>P(z,u)	证据（Evidence）：观测 z 和输入 u 本身出现的概率
<br>当我们未知先验就可以求解最大似然估计，在什么样的状态下，最可能观测到数据因为直接获得后验分布很困难，所以我们求得状态最优估计，使得在该状态下后验概率最大。
    - **当观测噪声是高斯分布时，“找最可信的位姿和地图”（最大似然）可以转化为 “最小化观测误差的加权平方和”（最小二乘）**
    <br>(xk​,yj​)∗=argmin(zk,j​−h(xk​,yj​))⊤Qk,j−1​(zk,j​−h(xk​,yj​))Qk,j​ 是 “观测噪声的协方差矩阵”，描述了观测误差的统计特性
   - **非线性最小二乘**
 <br>对于无法得知全局性质的目标函数，我们没办法求导获得极值，因此需要利用迭代的方式，不断更新当前的优化变量，通过不断增加x，找到最小的函数值。
   - **一阶、二阶梯度法**
<br>将目标函数在目标点附近展开，一阶前面的系数成为雅可比矩阵，二阶前面的系数成为海塞矩阵。对应的求解方法成为一阶梯度或者二阶梯度法。
<br>最速下降法：一阶的时候取增量为反向梯度，X=-J，目标函数一定会下降。
<br>牛顿法：HX=-J
   - **高斯牛顿法**（专门用于解决非线性最小二乘问题）
   - https://i-blog.csdnimg.cn/direct/61adda3ac98d40b4a0c1ec73bab704ee.png
   - **列文伯格-马夸尔特方法**






















































        
 



